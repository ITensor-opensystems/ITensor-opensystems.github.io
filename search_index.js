var documenterSearchIndex = {"docs":
[{"location":"api/GlobalFunctionApproximation.html#GlobalFunctionApproximation","page":"GlobalFunctionApproximation","title":"GlobalFunctionApproximation","text":"","category":"section"},{"location":"api/GlobalFunctionApproximation.html","page":"GlobalFunctionApproximation","title":"GlobalFunctionApproximation","text":"Modules = [GlobalFunctionApproximation]","category":"page"},{"location":"api/GlobalFunctionApproximation.html#ITensorsOpenSystems.GlobalFunctionApproximation.augustbanuls","page":"GlobalFunctionApproximation","title":"ITensorsOpenSystems.GlobalFunctionApproximation.augustbanuls","text":"augustbanuls(funcs,A,U0,maxiter;kwargs...)\n\nEvaluates functions of the form Tr[f(A)], where A is a Hermian operator given as an MPO and f is an arbirary function, using the algorithm in  August,Banuls (2018).\n\nAccepts either a single function or a list of functions [f,g,h...] to  evaluate Tr[f(A)],Tr[g(A)],Tr[h(A)]... simultaniously, as this is  substantially more efficent that running the algorithm separately for each  function.\n\n#Arguments     funcs: The function or list of functions to be evaluated on the target             matrix     A: The argument Hermitian matrix on which the functions are to act     U0: A unitary matrix, given as an MPO with the same set of indices as m         which acts as an inital value of the iteration     maxiter: The maximum number of loops of the algorithm, after which it               will terminate and return the result, even if the desired               convergence has not been achieved #Key word arguments     tol: The maximum desired error for the algorithm to terminate     cuttoff, maxdim, mindim: Determine the truncation conditions for the MPO                              operations in the usual way, the same as                               for built in ITensors functions.\n\n\n\n\n\n","category":"function"},{"location":"api/QuantumTrajectories.html#QuantumTrajectories","page":"QuantumTrajectories","title":"QuantumTrajectories","text":"","category":"section"},{"location":"api/QuantumTrajectories.html","page":"QuantumTrajectories","title":"QuantumTrajectories","text":"Modules = [QuantumTrajectories]","category":"page"},{"location":"api/QuantumTrajectories.html#ITensorsOpenSystems.QuantumTrajectories.trajectory-Tuple{Function, Any, ITensors.ITensorMPS.MPS, Real}","page":"QuantumTrajectories","title":"ITensorsOpenSystems.QuantumTrajectories.trajectory","text":"trajectory(evolve::<:Function, jumpops, ψ0::MPS,jumptimes)::Vector{MPS}\n\nCalculates the evolution of the states ψ0 along a single jump trajectory. The function  evolve(ψ,t1,t2) time evolves the state ψ from time t1 to time t2 with no jumps taking place. The jump operators, jumpops, are given as an iterable of opjects that can be  applyed to an MPS with ITensors.apply, i.e. MPOs, ITensors or vectors of ITensors.  The state is evolved from jumptimes[1] to jumptimes[end], checking if a jump should occure at each jumptime.\n\nReturns the state at each point in time along the trajectory in sampletimes\n\n##Example\n\nimport Dates:second,now\nusing ITensors\nusing ITensorTDVP\n\nN = 5\nJ = 1.0\nγ = 0.5\n\nindices = siteinds(\"S=1/2\",N)\n\nHop = OpSum()\n\n# Hermitian part of the Hamiltonian\nfor i = 1:(N-1)\n    Hop += J, \"Sz\", i, \"Sz\", i+1\nend\n\n# Non-Hermitian part of the Hamiltonian\nHop += -im*γ/2, \"Sp\", 1, \"Sm\", 1\nHop += -im*γ/2, \"Sm\", N, \"Sp\", N\n\nH = MPO(Hop,indices)\n\n# Define the jump operators corresponding\n# the non Hermitian part of H\njumpops = [γ * op(\"Sm\",1), γ * op(\"Sp\",N)]\n\nψ0 = randomMPS(indices)\n\n# We want to evolve the systems for 0 to tfinal, with potential jumps every tstep\ntfinal = 5\ntstep = 0.5\n\n#Seed the random number generator\nseed!(second(now()))\n\n# Final calculate the trajectory\ntrajectory_ψ = trajectory(jumpops, ψ0, 0:tstep,tfinal) do ψ, t1, t2\n    # Between jumps, evolve the system under H by TDVP\n    return tdvp(H,ψ,(t2-t1);cutoff=1e-7,normalize=false)\nend\n\nsee also: quantumtrajectories\n\n\n\n\n\n","category":"method"},{"location":"api/Vectorization.html#Vectorization","page":"Vectorization","title":"Vectorization","text":"","category":"section"},{"location":"api/Vectorization.html","page":"Vectorization","title":"Vectorization","text":"Modules = [Vectorization, Vectorization.MPSClones]","category":"page"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.anticommutatorapply-Tuple{Any}","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.anticommutatorapply","text":"anticommutatorapply(q)\n\nConstructs the vectorized operator representation of the operator\nanticommutator {q,⋅} as an autoMPO object\n\nsee also: `commutatorapply`, `leftrightapply`\n\n\n\n\n\n","category":"method"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.commutatorapply-Tuple{Any}","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.commutatorapply","text":"commutatorapply(q)\n\nConstructs the vectorized operator representation of the operator\ncommutator [q,⋅] as an autoMPO object\n\nsee also: `anticommutatorapply`, `leftrightapply`\n\n\n\n\n\n","category":"method"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.dissipator-Tuple{Vector, Any, Vararg{Any}}","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.dissipator","text":"dissipator(opsum::Vector, fatsys)\n\n# Arguments\n- `opsum::Vector`: Vector of OpSums\n- `fatsys`: Vectorized system\n\n# Examples\n\n...\n\n\n\n\n\n","category":"method"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.fatsiteinds-Tuple{Any, Any}","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.fatsiteinds","text":"fatsiteinds(tag::String, N::Integer; kwargs...)\n\n# Arguments\n- `tag::String`: the name of the base space to vectorize\n- `N::Integer`: the number of site indices to create\n- `operators::Vector{String}`: (Optional) A vector of operators\n\n# Examples\n```\njulia> fatsys = fatsiteinds(\"S=1/2\", 3)\n3-element Vector{ITensors.Index{Int64}}:\n(dim=4|id=770|\"S=1/2Vec,Site,n=1\")\n(dim=4|id=704|\"S=1/2Vec,Site,n=2\")\n(dim=4|id=428|\"S=1/2Vec,Site,n=3\")\n\njulia> operators = [\"Z\", \"X\", \"Y\", (\"Sp\", \"Sm\")]\n4-element Vector{Any}:\n\"Z\"\n\"X\"\n\"Y\"\n(\"Sp\", \"Sm\")\n\njulia> fatsys = fatsiteinds(\"S=1/2\", 3, operators)\n3-element Vector{ITensors.Index{Int64}}:\n(dim=4|id=625|\"S=1/2Vec,Site,n=1\")\n(dim=4|id=31|\"S=1/2Vec,Site,n=2\")\n(dim=4|id=697|\"S=1/2Vec,Site,n=3\")\n```\n\nCreate an array of N physical site indices of type tag within an vectorized space. Keyword arguments can be used to specify quantum number conservation, see the space function corresponding to the site type tag for supported keyword arguments. These keyword arguments are passed through to the ITensors.siteinds function.\n\n\n\n\n\n","category":"method"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.operatorconj-Tuple{ITensorsOpenSystems.Vectorization.VectorizedDensityMatrix}","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.operatorconj","text":"operatorconj(rho::VectorizedDensityMatrix)::VectorizedDensityMatrix\n\nPerforms the hermitian conjugate on a vectorized density matrix\n\n\n\n\n\n","category":"method"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.unvectorize_density_matrix!-Tuple{ITensorsOpenSystems.Vectorization.VectorizedDensityMatrix, Vector{<:ITensors.Index}}","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.unvectorize_density_matrix!","text":"unvectorize_density_matrix!(m::ITensors.MPS,unvectorized_inds::Vector{<:ITensors.Index})::ITensors.MPO\n\nUndoes the vectorization of a VectorizedDensityMatrix, in place, resulting in an MPO. The indices of the resulting MPO are given by unvectorized_inds\n\n\n\n\n\n","category":"method"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.vectorize_density_matrix!-Tuple{ITensors.ITensorMPS.MPO, Vector{<:ITensors.Index}}","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.vectorize_density_matrix!","text":"vectorize_density_matrix!(o::ITensors.MPO,vectorizedinds::Vector{<:ITensors.Index})::VectorizedDensityMatrix\n\nTreating the MPO as a density matrix, performs fat vectorization in place, resulting in a VectorizedDensityMatrix with indices given by vectorizedinds\n\nsee also: VectorizedDensityMatrix\n\n\n\n\n\n","category":"method"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.vectorizedexpect!-Tuple{ITensors.ITensorMPS.MPO, Union{ITensors.ITensorMPS.MPS, ITensorsOpenSystems.Vectorization.VectorizedDensityMatrix}}","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.vectorizedexpect!","text":"vectorizedexpect!(A::ITensors.MPO,ρ::ITensors.MPS)\n\nEvaluates the expecation value Tr(Aρ), where A is an MPO and  ρ is the vectorized density matrixrepresented as an MPS.\n\nNote that A is not a vectorized operator here and should  act on the unvectorized space.\n\nThis function will modify the operator A, but leave the  state ρ unchanged\n\n\n\n\n\n","category":"method"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.vectorizedexpect-Tuple{ITensors.ITensorMPS.MPO, Union{ITensors.ITensorMPS.MPS, ITensorsOpenSystems.Vectorization.VectorizedDensityMatrix}}","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.vectorizedexpect","text":"vectorizedexpect(A::ITensors.MPO,ρ::ITensors.MPS)\n\nEvaluates the expecation value Tr(Aρ), where A is an MPO and  ρ is the vectorized density matrixrepresented as an MPS.\n\nNote that A is not a vectorized operator here and should  act on the unvectorized space. \n\n\n\n\n\n","category":"method"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.vectorizedexpect-Tuple{Union{AbstractString, Matrix}, Union{ITensors.ITensorMPS.MPS, ITensorsOpenSystems.Vectorization.VectorizedDensityMatrix}}","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.vectorizedexpect","text":"vectorizedexpect(operator::Union{String,Matrix},vectorisedstate::ITensors.MPS)# TODO makes sites into a keyword to match ITensors.expect\n\n...\n\n\n\n\n\n","category":"method"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.vectorizedexpect-Tuple{Union{ITensors.Ops.Op, ITensors.LazyApply.Sum{ITensors.LazyApply.Scaled}, ITensors.LazyApply.Prod{ITensors.Ops.Op}}, Union{ITensors.ITensorMPS.MPS, ITensorsOpenSystems.Vectorization.VectorizedDensityMatrix}}","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.vectorizedexpect","text":"vectorizedexpect(operator::Union{ITensors.Op,ITensors.Prod{ITensors.Op},ITensors.Sum{ITensors.Scaled}},vectorisedstate::ITensors.MPS)\n\n...\n\n\n\n\n\n","category":"method"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.MPSClones.@cloneMPS-Tuple{Any}","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.MPSClones.@cloneMPS","text":"Creates a struct, which is a subclass of ITensors.AbstractMPS, which implements the interface that, as far as possible, implements the interface that ITensor assumes for AbstractMPSs\n\n\n\n\n\n","category":"macro"},{"location":"developers/code_layout.html#code_layout","page":"Code layout","title":"Code layout","text":"","category":"section"},{"location":"developers/code_layout.html","page":"Code layout","title":"Code layout","text":"Cover the design decisions of the code and how we've laid out each submodule etc.","category":"page"},{"location":"developers/VectorizationCore.html#VectorizationCore","page":"VectorisationCore","title":"VectorizationCore","text":"","category":"section"},{"location":"developers/VectorizationCore.html","page":"VectorisationCore","title":"VectorisationCore","text":"Modules = [ITensorsOpenSystems._VectorizationCore]","category":"page"},{"location":"developers/VectorizationCore.html#ITensorsOpenSystems._VectorizationCore.vectorization_sigil","page":"VectorisationCore","title":"ITensorsOpenSystems._VectorizationCore.vectorization_sigil","text":"vectorization_sigil\n\nUsed in site tags to designate the vectorised version of a given site space i.e \"Fermion\" vectorizes to \"FermionVec\", \"S=1/2\" vectorizes to \"S=1/2Vec\",  etc. \n\n\n\n\n\n","category":"constant"},{"location":"developers/VectorizationCore.html#ITensorsOpenSystems._VectorizationCore.vectorizedop_sigil","page":"VectorisationCore","title":"ITensorsOpenSystems._VectorizationCore.vectorizedop_sigil","text":"vectorizedop_sigil\n\nUsed in op names to denote that the op is the vectorized product of two ops on the base space. For example \"σxᵀ⊗σy would denote the vectorized operator for left multiplying with σy and right multiplying with σx\n\n\n\n\n\n","category":"constant"},{"location":"developers/VectorizationCore.html#ITensorsOpenSystems._VectorizationCore.basespace-Tuple{ITensors.Index}","page":"VectorisationCore","title":"ITensorsOpenSystems._VectorizationCore.basespace","text":"basespace(idx::ITensors.Index)::String\n\nGiven an index for a vectorized site, returns the name of the site space prior to vectorization\n\n\n\n\n\n","category":"method"},{"location":"developers/VectorizationCore.html#ITensorsOpenSystems._VectorizationCore.basespace-Tuple{Union{ITensors.ITensorMPS.MPO, ITensors.ITensorMPS.MPS}}","page":"VectorisationCore","title":"ITensorsOpenSystems._VectorizationCore.basespace","text":"basespace(m::Union{ITensors.MPS,ITensors.MPO})::String\n\nGiven a Union of ...\n\n\n\n\n\n","category":"method"},{"location":"developers/VectorizationCore.html#ITensorsOpenSystems._VectorizationCore.build_vectorized_space","page":"VectorisationCore","title":"ITensorsOpenSystems._VectorizationCore.build_vectorized_space","text":"Builds the vectorized space for a given site type.\n\n# Arguments\n- `basespace_name::String`: the name of the base space to vectorize\n- `operators::Vector{String}`: A vector of operators\n- `conserve_qns::Bool`: Should quantum numbers be conserved\n- `conserve_qns_options::String`: If we are to conserve quantum numbers, how to do so, \n                                    valid options are \"difference\" or \"independent\"\n# Examples\n```jldoctest\njulia> build_vectorized_space(\"S=1/2\", [\"Z\", \"X\", \"Y\", (\"S+\", \"S-\")])\n\njulia> siteind(\"S=1/2Vec\")\n(dim=4|id=145|\"S=1/2Vec,Site\")\n```\n\n\n\n\n\n","category":"function"},{"location":"developers/VectorizationCore.html#ITensorsOpenSystems._VectorizationCore.build_vectorized_space_name-Tuple{Any}","page":"VectorisationCore","title":"ITensorsOpenSystems._VectorizationCore.build_vectorized_space_name","text":"build_vectorized_space_name(tag::String)\n\nCreate the vectorized space name\n\n\n\n\n\n","category":"method"},{"location":"developers/VectorizationCore.html#ITensorsOpenSystems._VectorizationCore.leftapply-Tuple{Any}","page":"VectorisationCore","title":"ITensorsOpenSystems._VectorizationCore.leftapply","text":"leftapply(op)\n\nConstructs the vectorized operator corresponding to left multiplication\nby `op` as an autoMPO object\n\nsee also: `rightapply`, `leftrightapply`\n\n\n\n\n\n","category":"method"},{"location":"developers/VectorizationCore.html#ITensorsOpenSystems._VectorizationCore.leftrightapply-Tuple{Any, Any}","page":"VectorisationCore","title":"ITensorsOpenSystems._VectorizationCore.leftrightapply","text":"leftrightapply(leftop,rightop)\nTakes a pair of autoMPO objects on the unvectorized space and constructs the \nautoMPO object on the vectorized space corresponding to left multiplying the density\nmatrix by `leftop` and right multiplying it by `rightop`\n\n# Example\n```julia-repl\njulia> leftop, rightop = OpSum(),OpSum()\njulia>leftop += \"σx\", 1\njulia>rightop += \"σz\", 1\n\njulia>leftrightapply(leftop,rightop)\nsum(\n    1.0, \"σzᵀ⊗σx\", 1\n)\n```\nsee also: `leftapply`, `rightapply`, `commutatorapply`, `commutator`, `lindbladdissipator`, `dissipator`\n\n\n\n\n\n","category":"method"},{"location":"developers/VectorizationCore.html#ITensorsOpenSystems._VectorizationCore.rightapply-Tuple{Any}","page":"VectorisationCore","title":"ITensorsOpenSystems._VectorizationCore.rightapply","text":"rightapply(op)\n\nConstructs the vectorized operator corresponding to right multiplication\nby `op` as an autoMPO object\n\nsee also: `leftapply`, `leftrightapply`\n\n\n\n\n\n","category":"method"},{"location":"developers/VectorizationCore.html#ITensorsOpenSystems._VectorizationCore.vectorizer-Tuple{Any}","page":"VectorisationCore","title":"ITensorsOpenSystems._VectorizationCore.vectorizer","text":"vectorizor(site_type::String)::ITensor\nvectorizor(site_type::SiteType)::ITensor\n\nReturns the vectorization tensor, which maps a pair of site indices\nin the vectorized space (with oposite directions), to a single index\nin the vectorized space.\n\nIt is recomended to always use this when combining or separating site indices\nto esure that a consitent convention for how the different indices correspond\nis maintained\n\n# Example\n```\n# We create some local site indices and some corrisponding\n# vectoprized indices\ns = siteinds(\"S=1/2\", 2)\nsv = siteinds(\"S=1/2Vec\",2)\n\n# We create a tensor using those local indices\nt = op(\"Sz\", s[1])\n\n# We set the indices on t to match those of the vectorization\n# tensor\nt *= delta(vectorizer_input(\"S=1/2\"),s[1])\nt *= delta(vectorizer_input(\"S=1/2\")', s[1]')\n\n# We combine the indices on t into a single \n# vecotorized index\nt *= vectorizer(\"S=1/2\")\n\n# We set the single index on t to be one of\n# our previously created vectorized indices\nt *= delta(vectorizer_output(\"s=1/2\"),sv[1])\n```\n\nsee also: `vectorizer_input`, `vectorizer_output`\n\n\n\n\n\n","category":"method"},{"location":"developers/VectorizationCore.html#ITensorsOpenSystems._VectorizationCore.vectorizer_input-Tuple{Any}","page":"VectorisationCore","title":"ITensorsOpenSystems._VectorizationCore.vectorizer_input","text":"vectorizer_input(sitetype::String)::Index\nvectorizer_input(sitetype::SiteType)::Index\n\nReturns the input (unvectorized) indices of the vectorization tensor.\nThe vectorization tensor has two copies of this index, one primed\n(directed in if there are conserved quantum numbers) corresponding\nto the left hand index of the unvectorized density matrix and one\nunprimed (directed out if there are conserved quantum numbers)\ncorresponding to the right hand index of the unvectorized desnity\nmatrix. \n\n# Example\n```\n# We create some local site indices and some corrisponding\n# vectoprized indices\ns = siteinds(\"S=1/2\", 2)\nsv = siteinds(\"S=1/2Vec\",2)\n\n# We create a tensor using those local indices\nt = op(\"Sz\", s[1])\n\n# We set the indices on t to match those of the vectorization\n# tensor\nt *= delta(vectorizer_input(\"S=1/2\"),s[1])\nt *= delta(vectorizer_input(\"S=1/2\")', s[1]')\n\n# We combine the indices on t into a single \n# vecotorized index\nt *= vectorizer(\"S=1/2\")\n\n# We set the single index on t to be one of\n# our previously created vectorized indices\nt *= delta(vectorizer_output(\"s=1/2\"),sv[1])\n```\n\nsee also: `vectorizer`, `vectorizer_output`\n\n\n\n\n\n","category":"method"},{"location":"developers/VectorizationCore.html#ITensorsOpenSystems._VectorizationCore.vectorizer_output-Tuple{Any}","page":"VectorisationCore","title":"ITensorsOpenSystems._VectorizationCore.vectorizer_output","text":"vectorizer_output(sitetype::String)::Index\nvectorizer_output(sitetype::SiteType)::Index\n\nReturns the output (vectorized) indices of the vectorization tensor.\nThe vectorization tensor has one unprimed (outfacing if quantum numbers are conserved)\ncopy of this index, corresponding to the vectorized index. \n\n# Example\n```\n# We create some local site indices and some corrisponding\n# vectoprized indices\ns = siteinds(\"S=1/2\", 2)\nsv = siteinds(\"S=1/2Vec\",2)\n\n# We create a tensor using those local indices\nt = op(\"Sz\", s[1])\n\n# We set the indices on t to match those of the vectorization\n# tensor\nt *= delta(vectorizer_input(\"S=1/2\"),s[1])\nt *= delta(vectorizer_input(\"S=1/2\")', s[1]')\n\n# We combine the indices on t into a single \n# vecotorized index\nt *= vectorizer(\"S=1/2\")\n\n# We set the single index on t to be one of\n# our previously created vectorized indices\nt *= delta(vectorizer_output(\"s=1/2\"),sv[1])\n```\n\nsee also: `vectorizer_input`, `vectorizer`\n\n\n\n\n\n","category":"method"},{"location":"api/SplitVectorization.html#SplitVectorization","page":"SplitVectorization","title":"SplitVectorization","text":"","category":"section"},{"location":"api/SplitVectorization.html","page":"SplitVectorization","title":"SplitVectorization","text":"Modules = [SplitVectorization SplitVectorization.MPSClones]","category":"page"},{"location":"api/SplitVectorization.html#ITensorsOpenSystems.SplitVectorization.MPSClones.@cloneMPS-Tuple{Any}","page":"SplitVectorization","title":"ITensorsOpenSystems.SplitVectorization.MPSClones.@cloneMPS","text":"Creates a struct, which is a subclass of ITensors.AbstractMPS, which implements the interface that, as far as possible, implements the interface that ITensor assumes for AbstractMPSs\n\n\n\n\n\n","category":"macro"},{"location":"api/AnalyticSolutions.html#AnalyticSolutions","page":"AnalyticSolutions","title":"AnalyticSolutions","text":"","category":"section"},{"location":"api/AnalyticSolutions.html","page":"AnalyticSolutions","title":"AnalyticSolutions","text":"Modules = [AnalyticSolutions]","category":"page"},{"location":"developers/guide.html#ITensorsOpenSystems.jl-Developer-Guide","page":"Development guide","title":"ITensorsOpenSystems.jl Developer Guide","text":"","category":"section"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"This guide will help you get setup with all the tools you need to contribute to the development of the package. We'll assume you have Julia >= 1.9 installed, if you haven't, please see the installation guide.","category":"page"},{"location":"developers/guide.html#Development-environment","page":"Development guide","title":"Development environment","text":"","category":"section"},{"location":"developers/guide.html#Clone-the-repo","page":"Development guide","title":"Clone the repo","text":"","category":"section"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"For this section we'll assume you've been given access to the ITensorsOpenSystems.jl repository.","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"First clone the repository","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"$ git clone git@github.com:ITensor-opensystems/ITensorsOpenSystems.jl.git","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"Then move into the package","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"$ cd ITensorsOpenSystems.jl","category":"page"},{"location":"developers/guide.html#Running-the-tests","page":"Development guide","title":"Running the tests","text":"","category":"section"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"Now you're setup you can try running the tests to make sure everthing required is installed and the tests pass on your system","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"First we'll start the Julia REPL, activate the package manager and activate the package","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"$ julia\njulia> ]\n(@v1.10) pkg> activate .\n    Activating project at `~/Documents/ITensorsOpenSystems`\n\n(ITensorsOpenSystems) pkg>","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"Now you're ready to run the tests","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":" (ITensorsOpenSystems) pkg> test","category":"page"},{"location":"developers/guide.html#Install-in-dev-mode","page":"Development guide","title":"Install in dev mode","text":"","category":"section"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"As you'll be modifying a local copy of the package during development you can install the package in dev mode. Make sure your terminal working directory is the root of the ITensorsOpenSystems.jl repository and then run","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"$ julia\njulia> ]\n(@v1.10) pkg> dev .","category":"page"},{"location":"developers/guide.html#Pre-commit-(optional)","page":"Development guide","title":"Pre-commit (optional)","text":"","category":"section"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"We use pre-commit to ensure commits meet the standards we expect. This tool runs some pre-commit hooks to run linting and formatting checks on the changes being made.","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"To install the pre-commit hooks run","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"$ pre-commit install\npre-commit installed at .git/hooks/pre-commit","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"On the first commit after install you'll see messages telling you the pre-commit environment is being initialized, this will only happen once.","category":"page"},{"location":"developers/guide.html#Bypassing-pre-commit","page":"Development guide","title":"Bypassing pre-commit","text":"","category":"section"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"If you find that pre-commit is causing issues you can bypass the hook by passing the -n flag when making a commit.","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"$ git commit -n -m \"commit message\"","category":"page"},{"location":"developers/guide.html#Using-Revise.jl","page":"Development guide","title":"Using Revise.jl","text":"","category":"section"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"The Revise.jl package allows changes you've made to the source code to become available in you current Julia session. Without Revise you'll need to restart your Julia session each time you make changes. Install the package using the package manager.","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"julia> ]\n(v1.10) pkg> add Revise","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"When you start a Julia REPL during development the first using statement should be using Revise. This will then enable Revise for the session. Alternatively if you're on Linux/macOS you can make sure Revise is started at the beginning of each Julia session by running","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"mkdir -p ~/.julia/config/ && echo \"using Revise\" >> ~/.julia/config/startup.jl","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"For more information see the documentation.","category":"page"},{"location":"developers/guide.html#Contributing","page":"Development guide","title":"Contributing","text":"","category":"section"},{"location":"developers/guide.html#Tutorial-driven-development","page":"Development guide","title":"Tutorial driven development","text":"","category":"section"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"As we've developed ITensorsOpenSystems.jl we've worked with tutorial driven development approach. This means that for each piece of functionality we want to add to the package we first write a tutorial. To do this we write out the function calls we'd like to make and the objects we expect to be returned.","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"It doesn't matter that those functions don't exist yet, we'll create them once we'll finished a first pass of the tutorial. The interface to each function doesn't have to be perfect on the first pass, write an almost complete tutorial and then start writing the code. As you write the code you'll realise some of the tutorial will need changing.","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"Work in an iterative way, improving the tutorial and code with each iteration. Once you've completed the code you'll have a complete tutorial that covers all of the new functionality. There shouldn't be any functionality in the project that isn't covered by a tutorial as users have no way of knowing this functionality exists.","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"We've tried to organise ITensorsOpenSystems.jl in an easy to understand way. To better understand why the code is organised as it is please first read our code layout guide. We'll now cover the process of adding or modifying functionality from start to finish.","category":"page"},{"location":"developers/guide.html#Feature-branches","page":"Development guide","title":"Feature branches","text":"","category":"section"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"As we develop ITensorsOpenSystems we use feature branches as we develop new functionality. Each piece of work should have a GitHub issue associated with it. This makes it easy to track work and discuss design ideas and track progress of the work. Let's create a new feature branch for some work described in issue 42.","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"We use the devel branch as our development branch, we'll first check it out and pull any recent changes.","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"$ git checkout devel\n$ git pull","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"Now we're ready to create our branch","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"$ git checkout -b Iss42/Foo","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"Here we've created a branch called Iss42/Foo. Starting the branch name with the issue number followed by a couple of descriptive words helps future us and our collaborators understand what's happening where.","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"Now we've created the branch make your commits, merging in the devel if the branch is longer lived, this helps prevent complicated merge conflicts further down the line.","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"Once you've finished the feature open a pull request on the ITensorsOpenSystems.jl repository and request a code review.","category":"page"},{"location":"developers/guide.html#Adding-documentation","page":"Development guide","title":"Adding documentation","text":"","category":"section"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"All our documentation is contained in Markdown files in a folder structure expected by Documenter.jl.","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"docs/\n    src/\n        getting_started/            <- tutorials for users and developers\n            installation.md         <- getting ITensorsOpenSystems.jl installed\n            ...\n        tutorials/                  <- in-depth end-to-end tutorials covering functionality\n            tutorial1.md            <- Tutorial covering creating an open quantum system\n            ...\n        AnalyticSolutions.md        <- API documentation for ChainMappings submodule\n        ChainMappings.md            <- API documentation for ChainMappings submodule\n        Superfermions.md            <- API documentation for Superfermions submodule\n        SplitVectorization.md       <- API documentation for SplitVectorization submodule\n        Vectorization.md            <- API documentation for Vectorization submodule\n        ...\n    .gitignore                      <- tell Git to ignore built documentation\n    make.jl                         <- Julia script containing build instructions\n    Project.toml                    <- Contains libraries used to create documentation","category":"page"},{"location":"developers/guide.html#Tutorials","page":"Development guide","title":"Tutorials","text":"","category":"section"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"If you're adding new functionality, create a new tutorial file in the tutorials folder.","category":"page"},{"location":"developers/guide.html#API-changes","page":"Development guide","title":"API changes","text":"","category":"section"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"If you're adding functions or objects that will be exported from the package you'll need add these to the API documentation in the file for that module. Let's add a new function to the Superfermions module.","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"Superfermions.rightapply\nSuperfermions.leftapply\nSuperfermions.my_new_function\n...","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"The @docs tag in the Markdown file is part of the syntax used by Documenter.jl when building the documentation. You can read more about that in the documentation.","category":"page"},{"location":"developers/guide.html#Building-the-documentation","page":"Development guide","title":"Building the documentation","text":"","category":"section"},{"location":"developers/guide.html#Updating-make.jl","page":"Development guide","title":"Updating make.jl","text":"","category":"section"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"If you've added any new files to the documentation you'll need to update the makedocs call in the make.jl file. This tells Documenter where to look for the API documentation and tutorials.","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"For example, to make Documenter.jl aware of a new tutorial you'll need to add it to the Tutorials section. Note that here we use ... to denote lines in the file not shown here.","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"...\n\nmakedocs(\n    sitename = \"ITensorsOpenSystems\",\n    format = Documenter.HTML(prettyurls = get(ENV, \"CI\", nothing) == \"true\"),\n    modules = [ITensorsOpenSystems],\n    pages = Any[\n        \"Introduction\" => \"index.md\",\n        \"API\" => [\n            \"AnalyticSolutions\" => \"AnalyticSolutions.md\",\n            \"GlobalFunctionApproximation\" => \"GlobalFunctionApproximation.md\",\n            ...\n        ],\n        \"Tutorials\" => [\n            \"Open Spin Systems\" => \"tutorials/tutorial1.md\",\n            \"My new tutorial\" => \"tutorials/my_tutorial.md\",\n        ]],\n)\n\n...\n","category":"page"},{"location":"developers/guide.html#Build","page":"Development guide","title":"Build","text":"","category":"section"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"We're now ready to build the documentation. Ensure your terminal working directory is the docs folder and then run","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"$ julia --project make.jl","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"This will build the documentation HTML files and write these to a build folder. Once it's finished you can open the documentation at build/index.html.","category":"page"},{"location":"developers/guide.html#Dealing-with-errors","page":"Development guide","title":"Dealing with errors","text":"","category":"section"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"You may encounter errors such as","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"[ Info: SetupBuildDirectory: setting up build directory.\n[ Info: Doctest: running doctests.\n[ Info: ExpandTemplates: expanding markdown templates.\n[ Info: CrossReferences: building cross-references.\n[ Info: CheckDocument: running document checks.\n┌ Error: 1 docstring not included in the manual:\n│\n│     ITensorsOpenSystems.MatrixConstruction.new_function :: Tuple{Any}\n│\n│ These are docstrings in the checked modules (configured with the modules keyword)\n│ that are not included in canonical @docs or @autodocs blocks.\n└ @ Documenter ~/.julia/packages/Documenter/2OZOh/src/utilities/utilities.jl:44","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"This means we've forgotten to add the MatrixConstruction.new_function function to the list of functions in the MatrixConstruction.md API documentation file.","category":"page"},{"location":"developers/guide.html#Writing-tests","page":"Development guide","title":"Writing tests","text":"","category":"section"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"We need to make sure that each function we add to the package behaves as we expect it to. We use the ReTestItems.jl package to run our tests. See their documentation for information on how to write tests using that framework.","category":"page"},{"location":"developers/guide.html#Pull-request-and-code-review","page":"Development guide","title":"Pull request and code review","text":"","category":"section"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"GitHub allows use to easily review code that's being added to the project. We've setup the repository to only allow merging of changes if they've passed a code review and have been given approval by a maintainer. This is an important process to ensure that","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"code is understood by others\ncode adheres to the standards expected\ncode is well documented","category":"page"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"This isn't meant to be a hurdle to contributing, it helps everyone better understand new features.","category":"page"},{"location":"developers/guide.html#GitHub-Actions-CI/CD","page":"Development guide","title":"GitHub Actions CI/CD","text":"","category":"section"},{"location":"developers/guide.html","page":"Development guide","title":"Development guide","text":"As part of the pull request the GitHub Actions runners will run some checks to make sure the code meets the standards we expect and that all the tests pass. See the results of our GitHub Actions runners here.","category":"page"},{"location":"api/HamiltonianBuilding.html#HamiltonianBuilding","page":"HamiltonianBuilding","title":"HamiltonianBuilding","text":"","category":"section"},{"location":"api/HamiltonianBuilding.html","page":"HamiltonianBuilding","title":"HamiltonianBuilding","text":"Modules = [HamiltonianBuilding]","category":"page"},{"location":"api/HamiltonianBuilding.html#ITensorsOpenSystems.HamiltonianBuilding.build_from_matrix-Tuple{AbstractMatrix, Any, Any}","page":"HamiltonianBuilding","title":"ITensorsOpenSystems.HamiltonianBuilding.build_from_matrix","text":"build_from_matrix(coefficents::AbstractMatrix, leftops, rightops,offset::Integer=0)::OpSum\n\nConstructs an AutoMPO representation of the expresion Σ{i,j} M{i,j} Li Rj where Li and Ri are operators on site i and M_{i,j} is a matrix of coefficents\n\nThe operators can be spesifed either as stings or as an iterable of strings. If an iterable is given, then the result is the product of the operators in the iterable, all at the same site, in the given order.\n\nThe leftops, corresponding to the first index of the matrix, are always placed to the right of the rightops, corresponding to the second. \n\nWhen considering a subset of sites, which does not start at the first site, an offset can be given which shifts the index of the first site by the given amount.\n\n#Examples\n\n# Build coefficent matrix\nm = [0.0 1.0\n     1.0 0.0]\n\n\n# Build hopping term\nhopping_ops = build_from_matrix(m,\"Cdag\",\"C\")\n\n# Build interaction term\nu = 0.1\ninteraction_ops = build_from_matrix(u * m, [\"Cdag\",\"C\"], [\"Cdag\".\"C\"])\n\n# Combine into a single Hamiltonian and build MPO\nh = OpSum()\nh += hopping_ops\nh += interaction_ops\n\nindices = siteinds(\"Fermion\",2)\nH = MPO(h,indices)\n\n\n\n\n\n","category":"method"},{"location":"api/HamiltonianBuilding.html#ITensorsOpenSystems.HamiltonianBuilding.insert_ancilla-Tuple{Any, Any}","page":"HamiltonianBuilding","title":"ITensorsOpenSystems.HamiltonianBuilding.insert_ancilla","text":"insert_ancilla(ops,system_sites)\n\nShifts positions of operators in autoMPO object ops to account for an ancilla site being inserted directly after  each site in system_sites.\n\nsee also insert_sites\n\n\n\n\n\n","category":"method"},{"location":"api/HamiltonianBuilding.html#ITensorsOpenSystems.HamiltonianBuilding.insert_sites-Tuple{ITensors.LazyApply.Applied{typeof(sum), Tuple{Array{ITensors.LazyApply.Applied{typeof(*), Tuple{C, ITensors.LazyApply.Prod{ITensors.Ops.Op}}, @NamedTuple{}}, 1}}, @NamedTuple{}} where C, Any}","page":"HamiltonianBuilding","title":"ITensorsOpenSystems.HamiltonianBuilding.insert_sites","text":"insert_sites(ops,sites)\n\nShifts the postions of the operators in autoMPO object ops to take account of additional sites being inserted at the positions given in sites. The the positions given in sites refer to positions in the order before any insertions are made.\n\n#Example\n\nops = OpSum()\nops += \"C\", 3, \"Cdag\",5\nops += 2.0, \"N\", 6\n\n# Add extra sites at positions 1,4 and 6, so that site 3 must be moved\n# 1 space to the right (to account for the addition at site 1), site\n# 5 must be moved over 2 places (for the additions at sites 1 and 4)\n# and position 6 must move to site 9 to account for the additions \n# at sites 1, 5 and the new 6.\ninsert_sites(ops,[1,4,6])\n> sum(\n    1.0 C(4,) Cdag(7)\n    2.0 N(9,)\n)\n\nsee also insert_ancilla\n\n\n\n\n\n","category":"method"},{"location":"api/AutoMPOHermitianConjugate.html#AutoMPOHermitianConjugate","page":"AutoMPOHermitianConjugate","title":"AutoMPOHermitianConjugate","text":"","category":"section"},{"location":"api/AutoMPOHermitianConjugate.html","page":"AutoMPOHermitianConjugate","title":"AutoMPOHermitianConjugate","text":"Modules = [AutoMPOHermitianConjugate]","category":"page"},{"location":"api/AutoMPOHermitianConjugate.html#ITensorsOpenSystems.AutoMPOHermitianConjugate.NotInSymbolicSetError","page":"AutoMPOHermitianConjugate","title":"ITensorsOpenSystems.AutoMPOHermitianConjugate.NotInSymbolicSetError","text":"NotInSymbolicSetError <: Exception\n\nAn error denoting that a particular operator passed to hermitianconj does not have a registered conjugate\n\n\n\n\n\n","category":"type"},{"location":"api/AutoMPOHermitianConjugate.html#ITensorsOpenSystems.AutoMPOHermitianConjugate.hermitianconj-Tuple{ITensors.LazyApply.Sum}","page":"AutoMPOHermitianConjugate","title":"ITensorsOpenSystems.AutoMPOHermitianConjugate.hermitianconj","text":"hermitianconj(autompo)\nReturns the Hermitian conjugate of an autompo object. \n\n# example\n```julia-repl\njulia> H = OpSum()\nsum(\n\n)\n\njulia> H += 2, \"S+\", 1, \"Sz\",1\nsum(\n2.0 S+(1,) Sz(1,)\n)\n\njulia> H += [1 im; 2 3], 2\nsum(\n2.0 S+(1,) Sz(1,)\n1.0 Complex{Int64}[1 + 0im 0 + 1im; 2 + 0im 3 + 0im](2,)\n)\n\njulia> hermconj(H)\nsum(\n2.0 Sz(1,) S-(1,)\n1.0 Complex{Int64}[1 + 0im 2 + 0im; 0 - 1im 3 + 0im](2,)\n)\n```\n\nsee also: `register_conjugate`\n\n\n\n\n\n","category":"method"},{"location":"api/AutoMPOHermitianConjugate.html#ITensorsOpenSystems.AutoMPOHermitianConjugate.register_conjugate-Tuple{AbstractString, AbstractString}","page":"AutoMPOHermitianConjugate","title":"ITensorsOpenSystems.AutoMPOHermitianConjugate.register_conjugate","text":"register_conjugate(op::AbstractString;quiet=false)\nregister_conjugate(op::AbstractString,::Nothing;quiet=false)\nregister_conjugate(op1::AbstractString,op2::AbstractString; kwargs...)\n\nregisters an the name of an op allowing hermconj to take its conjugate. If one argument is\ngiven the op is assumed to be Hermitian. If two strings are given, both are registered as\nconjgates of each other. If the `symmetric` keyword is set to false only the the first\nargument is registered, with the second argment as its conjugate.\n\nAn arbitrary function can be applied particular parameters when taking the conjugate. This is passed\nvia the `parameter_transforms` keyword, which expects a dictionary mapping symbols (the parameters to be modified)\nto the funcitons to apply. Different funcitons can be applied to the arguments of each element of a conjugate\npair by passing the `parameter_transforms1` and `parameter_transforms2` keywords.\n\nA function can also be applied to the entire operator before it is returned allowing for complete control of the\nreturned conjugate. This is passed via the `op_transform` keyword. Seperate functions can be passed for each operator\nin a pair via the `op_transform1` and `op_transform2` keywords.\n\nIf nothing is given as an argument then it registered as not being able to take its hermitian conjugate.\n\nIf an op has previously been registered it will be overwriten but a warning will be raised. The warning\ncan be supressed by passing the `quiet` keyword.\n\n# Example\n```julia-repl\njulia> H = Op(\"Macbeth\",1)\n\"Macbeth\"(1,)\n\njulia> hermitianconj(H)\nERROR: NotInSymbolicSetError \"The hermitian conjugate of \"Macbeth\"(1,) is not in the set of symbolically defined ops\"\nStacktrace:\n  [1] top-level scope\n    @ REPL[5]:1\n\njulia> register_conjugate(\"Macbeth\",\"MacbethDag\")\n\njulia> hermitianconj(H)\n\"MacbethDag\"(1,)\n```\n\nsee also: `hermitianconj`\n\n\n\n\n\n","category":"method"},{"location":"getting_started/installation.html#installation","page":"Installing Julia and ITensorsOpenSystems.jl","title":"Installing Julia and ITensorsOpenSystems.jl","text":"","category":"section"},{"location":"getting_started/installation.html#Installing-Julia","page":"Installing Julia and ITensorsOpenSystems.jl","title":"Installing Julia","text":"","category":"section"},{"location":"getting_started/installation.html","page":"Installing Julia and ITensorsOpenSystems.jl","title":"Installing Julia and ITensorsOpenSystems.jl","text":"To start using ITensorsOpenSystems.jl you'll need Julia >= 1.9 installed. To do this visit https://julialang.org/downloads/ and follow the instructions for your operating system. You may also use your operating system's package manager.","category":"page"},{"location":"getting_started/installation.html#Installing-ITensorsOpenSystems.jl","page":"Installing Julia and ITensorsOpenSystems.jl","title":"Installing ITensorsOpenSystems.jl","text":"","category":"section"},{"location":"getting_started/installation.html","page":"Installing Julia and ITensorsOpenSystems.jl","title":"Installing Julia and ITensorsOpenSystems.jl","text":"With Julia installed","category":"page"},{"location":"getting_started/installation.html","page":"Installing Julia and ITensorsOpenSystems.jl","title":"Installing Julia and ITensorsOpenSystems.jl","text":"Open a terminal and start the Julia REPL by typing julia\nType ] to enter the package manager\nEnter the command add https://github.com/ITensor-opensystems/ITensorsOpenSystems.jl.git\nOnce the installation is complete press backspace to take you to the julia> prompt\nEnter using ITensorsOpenSystems to ensure everything is installed","category":"page"},{"location":"getting_started/installation.html","page":"Installing Julia and ITensorsOpenSystems.jl","title":"Installing Julia and ITensorsOpenSystems.jl","text":"You're now ready to start one of our tutorials.","category":"page"},{"location":"api/Superfermions.html#Superfermions","page":"Superfermions","title":"Superfermions","text":"","category":"section"},{"location":"api/Superfermions.html","page":"Superfermions","title":"Superfermions","text":"Modules = [Superfermions]","category":"page"},{"location":"api/Superfermions.html#ITensorsOpenSystems.Superfermions.clear_cached_vacuums-Tuple{}","page":"Superfermions","title":"ITensorsOpenSystems.Superfermions.clear_cached_vacuums","text":"clear_cached_vacuums()\n\nDeletes all memorized left vacuum states created by leftvacuum.\n\nsee also leftvacuum, delete_cached_vacuuum\n\n\n\n\n\n","category":"method"},{"location":"api/Superfermions.html#ITensorsOpenSystems.Superfermions.delete_cached_vacuuum-Tuple{Vector{<:ITensors.Index}}","page":"Superfermions","title":"ITensorsOpenSystems.Superfermions.delete_cached_vacuuum","text":"delete_cached_vacuuum(indices::Vector{<:Index})::MPS\n\nDeletes the left vacuum state memorized by leftvacuum for the given set of indices. The deleted state is returned.\n\nsee also leftvacuum, clear_cached_vacuums\n\n\n\n\n\n","category":"method"},{"location":"api/Superfermions.html#ITensorsOpenSystems.Superfermions.leftapply-Tuple{T} where T","page":"Superfermions","title":"ITensorsOpenSystems.Superfermions.leftapply","text":"leftapply(o)\n\nCreates an autoMPO representation of the superfermion operator equivelant to left multiplying the density operator by o. o must be given as an autoMPO  object.\n\n#Examples\n\n# Build the operator standard Hilbert space operaotr C†_1 C_2 + N_1\no = OpSum()\no += \"Cdag\", 1 \"C\" 2\no += \"N\", 1\n\n# Build the superfermion operator ρ →(C†_1 C_2 + N_1)ρ as an autoMPO object\nl = leftapply(o)\n\n# Build an MPO representation of l\nindices = superfermioninds(4)\nl_mpo = MPO(l,s)\n\nsee also rightapply, leftrightapply, commutatorapply, anticommutatorapply\n\n\n\n\n\n","category":"method"},{"location":"api/Superfermions.html#ITensorsOpenSystems.Superfermions.leftrightapply-Tuple{Any, Any}","page":"Superfermions","title":"ITensorsOpenSystems.Superfermions.leftrightapply","text":"leftrightapply(ol,or)\n\nCreates an autoMPO representation of the superfermion operator equivelant to simultaniously left multiplying the density operator by ol and right multiplying by or. ol and or must be given as autoMPO objects.\n\n#Examples\n\n# Build the standard Hilbert space operator 2.0 C_1 C†_2\ns_left = OpSum()\ns_left += 2.0 \"C\", 1, \"Cdag\" 2\n\n# Build the standard Hilbert space operator N_1 + 2.0 N_2\ns_right = OpSum()\ns_right += \"N\", 1\ns_right += 2.0, \"N\", 2\n\n# Build the superfermion operator ρ → (2.0 C_1 C†_2) ρ (N_1 + 2.0 N_2)\nsuperfemion_op = leftrightapply(s_left,s_right)\n\n# Construct superfermion MPO\nindices = superfermioninds(2)\nO = MPO(superfemion_op,indices)\n\nsee also leftapply, rightapply, commutatorapply, anticommutatorapply\n\n\n\n\n\n","category":"method"},{"location":"api/Superfermions.html#ITensorsOpenSystems.Superfermions.leftvacuum-Tuple{Vector{<:ITensors.Index}}","page":"Superfermions","title":"ITensorsOpenSystems.Superfermions.leftvacuum","text":"leftvacuum([NoCache,] indices::Vector{<:Index})::MPS\n\nReturns the left vacuum state for a set of superfermion indices. Memorization is used to avoid repeatedly recomputing the state for a given set of indices. If the NoCache option is given, the state will always be directly computed, without querrying or overwriting the cached state.\n\n#Examples\n\nsuperfermion_indices = superfermioninds(5) # Create a set of indices describing a system \nleftvac1 = leftvacuum(superfermion_indices) # Create the left vacuum statte for the system, memorizing the result\nleftvac2 = leftvacuum(superfermion_indices) # Uses the cached result. No additional calculation is carried out\nleftvac3 = leftvacuum(NoCache, superfermion_indices) # Ignores the cahce and recomputes the left vacuum state \n\nSee also clear_cached_vacuums, delete_cached_vacuuum`\n\n\n\n\n\n","category":"method"},{"location":"api/Superfermions.html#ITensorsOpenSystems.Superfermions.lindbladdissipator-Tuple{AbstractString, Integer}","page":"Superfermions","title":"ITensorsOpenSystems.Superfermions.lindbladdissipator","text":"lindbladdissipator(jump_op::AbstractString,i::Integer)::Sum\n\nCreates an autoMPO superfermion representation of a Lindblad dissipator with a jump operator jump_op on (physical) site i. #Examples\n\ndis = OpSum()\n\n# Add dissipator, removing fermions from the system, on site 1\n# 0.1 * (C ρ C† - 1/2 { C†C,ρ } )\nextraction_rate = 0.1\ndis += extraction_rate * lindbladdissipator(\"C\",1)\n\n# Add dissipator, injecting fermions into the system, on site 5\n# 0.3 * ( C† ρ C - 1/2 { CC†,ρ })\ninjection_rate = 0.3\ndis += injection_rate * lindbladdissipator(\"Cdag\",5)\n\n# Build operator as MPO\nindices = superfermioninds(5)\ndissipation_MPO = MPO(dis,indices)\n\nsee also leftrightapply, commutatorapply, anticommutatorapply, leftapply, rightapply\n\n\n\n\n\n","category":"method"},{"location":"api/Superfermions.html#ITensorsOpenSystems.Superfermions.rightapply-Tuple{T} where T","page":"Superfermions","title":"ITensorsOpenSystems.Superfermions.rightapply","text":"rightapply(o)\n\nCreates an autoMPO representation of the superfermion operator equivelant to right multiplying the density operator by o. o must be given as an autoMPO  object.\n\n#Examples\n\n# Build the operator standard Hilbert space operaotr C†_1 C_2 + N_1\no = OpSum()\no += \"Cdag\", 1 \"C\" 2\no += \"N\", 1\n\n# Build the superfermion operator ρ →ρ(C†_1 C_2 + N_1) as an autoMPO object\nr = leftapply(o)\n\n# Build an MPO representation of r\nindices = superfermioninds(4)\nr_mpo = MPO(r,s)\n\nsee also leftapply, leftrightapply, commutatorapply, anticommutatorapply\n\n\n\n\n\n","category":"method"},{"location":"api/Superfermions.html#ITensorsOpenSystems.Superfermions.superfermioncorrelation-Tuple{ITensors.ITensorMPS.MPS, Union{String, Matrix}, Union{String, Matrix}}","page":"Superfermions","title":"ITensorsOpenSystems.Superfermions.superfermioncorrelation","text":"superfermioncorrelation(state::MPS,op1::Union{String,Matrix},op2::Union{String,Matrix}; normalize=true)::Matrix{ITensors.promote_itensor_eltype(state)}\n\nCalculates the correlation matrix for a pair of operators op1 and op2 for a given state, that is calculates the expectation of the operator op1i * op2j for i and j iterating through each physical site of the system.\n\n#Example\n\nindices = superfermioninds(5)\nrho = leftvacuum(indices)\ng = superfermioncorrelation(rho,\"Cdag\",\"C\")\n\nsee also superfermionexpect\n\n\n\n\n\n","category":"method"},{"location":"api/Superfermions.html#ITensorsOpenSystems.Superfermions.superfermionexpect-Tuple{ITensors.ITensorMPS.MPS, AbstractString}","page":"Superfermions","title":"ITensorsOpenSystems.Superfermions.superfermionexpect","text":"superfermionexpect(state::MPS,oper::AbstractString;[sites,] normalize::Bool=true)::Vector{ITensors.promote_itensor_eltype(rho)}\n\nCalculates the expectation value of the operator oper on each physical site of the superfermion state state. If the sites keyword is given, the expectation is only evaluated for those physical sites in the given range. If normalize is true the result will be normalized by the trace of the input state.\n\n#Example\n\nindices = superfermioninds(5)\nρ = leftvacuum(indices)\n\n# Compute the occupation of all sites\noccupations = superfermionexpect(ρ,\"N\")\n\n# Compute the occupation of only sites 1 and 3\noccupations_1_and_3 = superfermionexpect(ρ,\"N\";sites=[1,3]) \n\nsee also superfermioncorrelation\n\n\n\n\n\n","category":"method"},{"location":"api/Superfermions.html#ITensorsOpenSystems.Superfermions.superfermioninds-Tuple{Integer}","page":"Superfermions","title":"ITensorsOpenSystems.Superfermions.superfermioninds","text":"superfermioninds(n::Integer;conserve_qns=false)::Vector{<:Index}\n\nConstructs a set of superfermion indices for n physical sites. That is  the result will contain 2n indices, with n system indices and n ancilla indices. If conserve_qns=true then the indices will keep track of particle number flux.\n\n\n\n\n\n","category":"method"},{"location":"api/Superfermions.html#ITensorsOpenSystems.Superfermions.superfermiontrace-Tuple{ITensors.ITensorMPS.MPS}","page":"Superfermions","title":"ITensorsOpenSystems.Superfermions.superfermiontrace","text":"superfermiontrace(rho::MPS)::ITensors.promote_itensor_eltype(rho)\n\nCalculates the trace of the density matrix given as a superfermion state rho\n\n\n\n\n\n","category":"method"},{"location":"tutorials/tutorial1.html#tutorial1","page":"Open Spin Systems","title":"Tutorial 1 - End to end","text":"","category":"section"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"using ITensors\nusing ITensorsOpenSystems\nusing Plots\nusing LinearAlgebra","category":"page"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"The density matrix rho of a dissipative spin system evolves as","category":"page"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"fracddtrho(t) = mathcalLrho(t)","category":"page"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"defined by the Liouvillian superoperator","category":"page"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"mathcalLrho(t) = -iHrho(t) + sum_q=1^JmathcalD_A_jrho","category":"page"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"where H is the system Hamiltonian and ","category":"page"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"mathcalD_Arho = Arho A^dagger - frac12A^dagger A rho - frac12rho A^dagger A","category":"page"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"is the Lindblad dissipator for a jump operator A. In this tutorial we will consider a system comprising a chain of N spin-1/2's governed by the XXZ Hamiltonian with a transverse field","category":"page"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"H = sum_i=1^N-1left(sigma^x_isigma^x_i+1 + sigma^y_isigma^y_i+1 + Deltasigma^z_isigma^z_i+1right) + hsum_i=1^Nsigma^x_i","category":"page"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"and apply J=3 jump operators","category":"page"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"beginaligned\nA_1 = sqrtgamma_rm insigma^+_1\nA_2 = sqrtgamma_rm outsigma^-_N\nA_3 = sqrtgamma_rm dpsum_i=1^Nsigma^z_i\nendaligned","category":"page"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"describing the injection of spin uparrow excitations at the first spin, their ejection at the last spin, and dephasing of the collective z magnetization. We will consider small system sizes N to allow comparison to exact diagonalization.","category":"page"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"begin\n\tN    = 3    \t\t\t\t\t# Number of spins\n\tΔ    = 1.5  \t\t\t\t\t# Anisotropy of the spin-spin coupling\n\th    = 0.6  \t\t\t\t\t# Transverse field strength\n\tγin  = 0.4  \t\t\t\t\t# Spin-injection noise rate\n\tγout = 0.2  \t\t\t\t\t# Spin-ejection noise rate \n\tγdp  = 0.8  \t\t\t\t\t# Collective dephasing noise rate\nend;\n\nsystem = siteinds(\"S=1/2\",N); \t\t# Define system spin-1/2 Hilbert space\n\nfatsys = fatsiteinds(system); \t\t# Define the vectorized Hilbert space","category":"page"},{"location":"tutorials/tutorial1.html#Define-Hamiltonian-and-jump-operators","page":"Open Spin Systems","title":"Define Hamiltonian and jump operators","text":"","category":"section"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"We first construct the system Hamiltonian OpSum","category":"page"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"begin\n\tH = OpSum()\n\n\t# Open boundary chain:\n\tfor i = 1:(N-1)\n    \tH += h, \"X\", i \t\t\t\t# Transverse field\n    \n    \tH += 1, \"X\", i, \"X\", i+1 \t# XX term\n    \tH += 1, \"Y\", i, \"Y\", i+1 \t# YY term\n    \tH += Δ, \"Z\", i, \"Z\", i+1 \t# ZZ term\n\tend\n\tH += h, \"X\", N  \t\t\t\t# Transverse field on last spin\nend;","category":"page"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"Thenn define Lindblad jump operators","category":"page"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"begin\n\tA = fill(OpSum(), 3)         \t# An array of OpSum's for jump operators\n\n\tA[1] += sqrt(γin), \"Sp\", 1    \t# Spin injection\n\tA[2] += sqrt(γout), \"Sm\", N   \t# Spin ejection\n\n\tfor i = 1:N\n    \tA[3] += sqrt(γdp), \"Z\", i \t# Collective dephasing\n\tend\nend","category":"page"},{"location":"tutorials/tutorial1.html#Construct-MPOs","page":"Open Spin Systems","title":"Construct MPOs","text":"","category":"section"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"Hmpo = MPO(H,system);           \t# Build the system Hamiltonian MPO\n\nLH = im * commutator(H,fatsys); \t# Build the commutator MPO for the fat-system\n\nLD = dissipator(A,fatsys);      \t# Build the dissipator MPO for the fat-system\n\nL = LH + LD;                    \t# Full Liouvillian MPO for the fat-system\n\nLdagL = apply(dagprimes(L),L);   \t# Construct Liouvillian \"Hamiltonian\"","category":"page"},{"location":"tutorials/tutorial1.html#Compute-stationary-state","page":"Open Spin Systems","title":"Compute stationary state","text":"","category":"section"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"Perform standard DMRG sweeps to find the \"ground state\" of the Liovillian Hamiltonian.","category":"page"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"begin\n\tsweeps = Sweeps(10)\t\t\t\t# Initialize sweeps with number \n    maxdim!(sweeps,50,100,200,400,800,800,1000,1000,2000,2000) # Bond dimension      \n    cutoff!(sweeps,1E-10)  \t\t\t# Desired truncation error\n\tρ0 = randomMPS(fatsys, \"↑\"; linkdims=10) \t# Create a random initial state\nend\n\nval, ρ = dmrg(LdagL,ρ0,sweeps);\t\t# Find the steady-state ","category":"page"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"Now compute observables from the steady state:","category":"page"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"magz = expect(ρ,\"Sz\"); \t\t\t\t# Compute z-magnetization profile\n\nzz = correlation_matrix(ρ,\"Sp\",\"Sm\"); \t# Compute S+S- correlation matrix \n","category":"page"},{"location":"tutorials/tutorial1.html#Exact-diagonalization","page":"Open Spin Systems","title":"Exact diagonalization","text":"","category":"section"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"Compute the exact result for comparison. Start by constructing the full 2^2N times 2^2N matrix for the Liouvillian Hamiltonian:","category":"page"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"if N > 10\n\tthrow(\"System size too large for exact diagonalization\") \t# Don't continue\nend\n\nbegin\n\tLH_ed = im * full_commutator(H,fatsys); \n\tLD_ed = full_dissipator(A,fatsys); \n\tL_ed = LH_ed + LD_ed;\nend","category":"page"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"Now fully diagonalize to find the steady-state","category":"page"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"begin\n\tF = eigen(L_ed)\t\t\t\t# Diagonalize matrix\n\tE = F.values \t\t\t\t# Extract eigenvalues\n\tV = F.vectors \t\t\t\t# Extract eigenvectors\n\tind = findmin(E) \t\t\t# Locate the smallest eigenvalue (should be zero)\n\tρ_ed = V[:,ind] \t\t\t# Extract the corresponding eigenvector\n\tρ_ed = reshape(ρ_ed, (2^N,2^N)); \t# Reshape vector into a matrix\nend","category":"page"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"Compute observables from the steady-state","category":"page"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"magz_ed = expect(ρ_ed,\"Sz\"); \t\t\t\t# Compute z-magnetization profile\n\nzz_ed = correlation_matrix(ρ_ed,\"Sp\",\"Sm\"); # Compute S+S- correlation matrix","category":"page"},{"location":"tutorials/tutorial1.html#Compare-results","page":"Open Spin Systems","title":"Compare results","text":"","category":"section"},{"location":"tutorials/tutorial1.html","page":"Open Spin Systems","title":"Open Spin Systems","text":"begin\n\tplot(1:N, magz_ed, label=\"exact\")  \n\tscatter!(1:N, magz, label=\"MPO\") \n\theatmap(1:N, 1:N, real(zz), c = :heat)\n\tfontsize = 10\n\tnrow, ncol = size(zz)\n\tann = [(i,j, text(round(real(zz[i,j]), digits=3), fontsize, :white, :center))\n            for i in 1:nrow for j in 1:ncol]\n\t\t\tannotate!(ann, linecolor=:white)\n\theatmap(1:N, 1:N, real(zz_ed), c = :heat)\n\tfontsize = 10\n\tnrow, ncol = size(zz)\n\tann = [(i,j, text(round(real(zz_ed[i,j]), digits=3), fontsize, :white, :center))\n            for i in 1:nrow for j in 1:ncol]\n\t\t\tannotate!(ann, linecolor=:white)\nend","category":"page"},{"location":"api/Utils.html#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"api/Utils.html","page":"Utils","title":"Utils","text":"Modules = [Utils]","category":"page"},{"location":"api/Utils.html#ITensorsOpenSystems.Utils.MPOtomatrix-Tuple{ITensors.ITensorMPS.MPO}","page":"Utils","title":"ITensorsOpenSystems.Utils.MPOtomatrix","text":"MPOtomatrix(s::MPO)::Matrix{<:Number}\n\nConverts and MPO into a standard julia matrix\n\nwarning: the matrix dimension can get large quickly. Only use on operators with a small number of sites\n\n\n\n\n\n","category":"method"},{"location":"api/Utils.html#ITensorsOpenSystems.Utils.MPStovector-Tuple{ITensors.ITensorMPS.MPS}","page":"Utils","title":"ITensorsOpenSystems.Utils.MPStovector","text":"MPStovector(s::MPS)::Vector{<:Number}\n\nConverts and MPS into a standard julia vector\n\nwarning: the vector dimension can get large quickly. Only use on states with a small number of sites\n\n\n\n\n\n","category":"method"},{"location":"api/Utils.html#ITensorsOpenSystems.Utils.dagprimes!-Tuple{ITensors.ITensorMPS.AbstractMPS}","page":"Utils","title":"ITensorsOpenSystems.Utils.dagprimes!","text":"dagprimes!(o;kwargs...)\n\nTakes the Hermitian conjugate of an MPO in place, using the convention that input indices have prime level 0 and the corresponding output indices are the same index with prime level 1. Accepts the same keyword arguments  as dag, prime and similar functions\n\nsee also: dagprimes\n\n\n\n\n\n","category":"method"},{"location":"api/Utils.html#ITensorsOpenSystems.Utils.dagprimes-Tuple{Any}","page":"Utils","title":"ITensorsOpenSystems.Utils.dagprimes","text":"dagprimes(o;kwargs...)\n\nTakes the Hermitian conjugate of an MPO or ITensor, using the convention that input indices have prime level 0 and the corresponding output indices are the same index with prime level 1. Accepts the same keyword arguments  as dag, prime and similar functions\n\n\n\n\n\n","category":"method"},{"location":"api/Utils.html#ITensorsOpenSystems.Utils.reduced_density_matrix-Tuple{ITensors.ITensorMPS.MPO, Any}","page":"Utils","title":"ITensorsOpenSystems.Utils.reduced_density_matrix","text":"reduced_density_matrix[!](ρ::MPO,remaining_indices;kwargs...)::MPO\nreduced_density_matrix(ψ::MPS,remaining_indices;kwargs...)::MPO\n\nGiven a state as an MPO or MPS calculates the reduced density matrix obtained by tracing  all the indices except those in remaining_indices, giving the result as an MPO. If the  original state is given as an MPO, an in-place version exists.\n\nA truncation of the MPO can be incorperated. Parameters for this e.g. cutoff, maxdim, etc. can be passed as extra keyword arguments.\n\nExample\n\ns = siteinds(\"S=1/2\",4)\n\n# density matrix for the product state with all spins pointing up\nρ = MPO(s, \"ProjUp\")\n\n# traces out sites 3 and 4 to give the reduced density matrix on sites 1 and 2\nρ_12 = reduced_density_matrix(ρ,s[1:2])\n\n\n\n\n\n","category":"method"},{"location":"api/Utils.html#ITensorsOpenSystems.Utils.stateequality-Tuple{ITensors.ITensorMPS.MPS, ITensors.ITensorMPS.MPS}","page":"Utils","title":"ITensorsOpenSystems.Utils.stateequality","text":" stateequality(s1::MPS,s2::MPS;kwargs...)::Bool\n\nReturns true if the MPSs s1 and s2 correspond to the same tensor, to within numerical precision, and false otherwise. This is useful due to the level of gauge freedom in representing an MPS\n\nIt can optionally be passed an atol and rtol to set the absolute and relative numerical tolerance respectively.  \n\n\n\n\n\n","category":"method"},{"location":"tutorials/fermions.html#Fermions","page":"Fermions","title":"Fermions","text":"","category":"section"},{"location":"tutorials/fermions.html","page":"Fermions","title":"Fermions","text":"...","category":"page"},{"location":"index.html#Documentation","page":"Introduction","title":"Documentation","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"ITensorsOpenSystems.jl Documentation","category":"page"},{"location":"index.html#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"index.html#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Presenting the new ITensorsOpenSystems.jl package for simulation of quantum systems subject to noise and dissipation from the surrounding environment. Such modelling is essential for understanding the functionality of novel quantum devices. We’ll cover developing a new Julia package for quantum simulations and the experiences of an RSE learning Julia, its tooling and relearning some quantum mechanics.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"With the fast development of quantum technologies there is growing interest to simulate the dynamics of small quantum systems/devices. All such systems will be “open” to noise and dissipation caused by the surrounding environment. Realistic design of new quantum devices thus necessitates modelling open quantum systems. OpenSystems.jl is a new Julia package developed at the University of Bristol to facilitate such simulations. It builds on the successful ITensors.jl package where the states of quantum systems are described compactly by tensor networks. It adds a user friendly and unified interface for handling the dynamics and steady-state behaviour of Markovian quantum noise.","category":"page"},{"location":"index.html#Installation-Guide","page":"Introduction","title":"Installation Guide","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"As ITensorsOpenSystems is currently under heavy development please install the package from this GitHub repository. You can do this by opening a Julia REPL, activating the package manager and adding the repository path.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"'julia julia> ] (@v1.10) pkg> add https://github.com/ITensor-opensystems/ITensorsOpenSystems.jl.git'","category":"page"},{"location":"index.html#Something-inbetween-Tutorials/API","page":"Introduction","title":"Something inbetween Tutorials/API","text":"","category":"section"},{"location":"index.html#Tutorials","page":"Introduction","title":"Tutorials","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Tutorial 1- Example open spin systems","category":"page"},{"location":"index.html#API-Reference","page":"Introduction","title":"API Reference","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"AnalyticSolutions\nChainMappings\nUtils\nGlobalFunctionApproximation\nHamiltonianBuilding\nMatrixConstruction\nQuantumTrajectories\nSplitVectorization\nSuperfermions\nVectorization\n_VectorizationCore","category":"page"},{"location":"api/ChainMappings.html#ChainMappings","page":"ChainMappings","title":"ChainMappings","text":"","category":"section"},{"location":"api/ChainMappings.html","page":"ChainMappings","title":"ChainMappings","text":"Modules = [ChainMappings]","category":"page"},{"location":"api/MatrixConstruction.html#MatrixConstruction","page":"MatrixConsreuction","title":"MatrixConstruction","text":"","category":"section"},{"location":"api/MatrixConstruction.html","page":"MatrixConsreuction","title":"MatrixConsreuction","text":"Modules = [MatrixConstruction]","category":"page"},{"location":"api/MatrixConstruction.html#ITensorsOpenSystems.MatrixConstruction.eachindval_collection-Tuple{Any}","page":"MatrixConsreuction","title":"ITensorsOpenSystems.MatrixConstruction.eachindval_collection","text":"If eachindval is passed a single index it produces an iterator generating a pair index => value If it is passed a multiple indices the iterator generates a tuple of pairs of values To get consitent behaviour in the case of a single value, we must, therefore, wrap the result of the iterator in a tuple\n\n\n\n\n\n","category":"method"}]
}
