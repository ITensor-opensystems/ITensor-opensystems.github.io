var documenterSearchIndex = {"docs":
[{"location":"api/GlobalFunctionApproximation.html#Documentation-for-ITensorsOpenSystems.GlobalFunctionApproximation","page":"GlobalFunctionApproximation","title":"Documentation for ITensorsOpenSystems.GlobalFunctionApproximation","text":"","category":"section"},{"location":"api/GlobalFunctionApproximation.html","page":"GlobalFunctionApproximation","title":"GlobalFunctionApproximation","text":"ITensorsOpenSystems.GlobalFunctionApproximation.augustbanuls\n","category":"page"},{"location":"api/GlobalFunctionApproximation.html#ITensorsOpenSystems.GlobalFunctionApproximation.augustbanuls","page":"GlobalFunctionApproximation","title":"ITensorsOpenSystems.GlobalFunctionApproximation.augustbanuls","text":"augustbanuls(funcs,A,U0,maxiter;kwargs...)\n\naugustbanuls(\nfunc::Function,\nA::ITensors.MPO,\nU0::ITensors.MPO,\nmaxiter::Int;\nkwargs...,\n\n) Evaluates functions of the form Tr[f(A)], where A is a Hermian operator given as an MPO and f is an arbirary function, using the algorithm in  August,Banuls (2018).\n\nAccepts either a single function or a list of functions [f,g,h...] to  evaluate Tr[f(A)],Tr[g(A)],Tr[h(A)]... simultaniously, as this is  substantially more efficent that running the algorithm separately for each  function.\n\n#Arguments     funcs: The function or list of functions to be evaluated on the target             matrix     A: The argument Hermitian matrix on which the functions are to act     U0: A unitary matrix, given as an MPO with the same set of indices as m         which acts as an inital value of the iteration     maxiter: The maximum number of loops of the algorithm, after which it               will terminate and return the result, even if the desired               convergence has not been achieved #Key word arguments     tol: The maximum desired error for the algorithm to terminate     cuttoff, maxdim, mindim: Determine the truncation conditions for the MPO                              operations in the usual way, the same as                               for built in ITensors functions.\n\n\n\n\n\n","category":"function"},{"location":"api/QuantumTrajectories.html#Documentation-for-ITensorsOpenSystems.QuantumTrajectories","page":"QuantumTrajectories","title":"Documentation for ITensorsOpenSystems.QuantumTrajectories","text":"","category":"section"},{"location":"api/QuantumTrajectories.html","page":"QuantumTrajectories","title":"QuantumTrajectories","text":"ITensorsOpenSystems.QuantumTrajectories.count\nITensorsOpenSystems.QuantumTrajectories.data\nITensorsOpenSystems.QuantumTrajectories.final_data\nITensorsOpenSystems.QuantumTrajectories.initial_data\nITensorsOpenSystems.QuantumTrajectories.quantumtrajectories\nITensorsOpenSystems.QuantumTrajectories.sampletimes\nITensorsOpenSystems.QuantumTrajectories.t_data\nITensorsOpenSystems.QuantumTrajectories.trajectory","category":"page"},{"location":"api/QuantumTrajectories.html#ITensorsOpenSystems.QuantumTrajectories.count","page":"QuantumTrajectories","title":"ITensorsOpenSystems.QuantumTrajectories.count","text":"count(traj::TrajectoriesResult) -> Integer\n\nArguments:\n\ntraj::TrajectoriesResult: A trajectories result instance.\n\nReturns:\n\nThe number of trajectories (columns in the raw data matrix) stored in traj.\n\n\n\n\n\n","category":"function"},{"location":"api/QuantumTrajectories.html#ITensorsOpenSystems.QuantumTrajectories.data","page":"QuantumTrajectories","title":"ITensorsOpenSystems.QuantumTrajectories.data","text":"data(traj::TrajectoriesResult) -> Matrix{MPS}\n\nArguments:\n\ntraj::TrajectoriesResult: A trajectories result instance.\n\nReturns:\n\nThe raw trajectory data stored in traj as a matrix of MPS.\n\n\n\n\n\n","category":"function"},{"location":"api/QuantumTrajectories.html#ITensorsOpenSystems.QuantumTrajectories.final_data","page":"QuantumTrajectories","title":"ITensorsOpenSystems.QuantumTrajectories.final_data","text":"final_data(traj::TrajectoriesResult) -> Vector{MPS}\n\nArguments:\n\ntraj::TrajectoriesResult: A trajectories result instance.\n\nReturns:\n\nThe final set of MPS (last row of raw_data) from the trajectories.\n\n\n\n\n\n","category":"function"},{"location":"api/QuantumTrajectories.html#ITensorsOpenSystems.QuantumTrajectories.initial_data","page":"QuantumTrajectories","title":"ITensorsOpenSystems.QuantumTrajectories.initial_data","text":"initial_data(traj::TrajectoriesResult) -> Vector{MPS}\n\nArguments:\n\ntraj::TrajectoriesResult: A trajectories result instance.\n\nReturns:\n\nThe initial set of MPS (first row of raw_data) from the trajectories.\n\n\n\n\n\n","category":"function"},{"location":"api/QuantumTrajectories.html#ITensorsOpenSystems.QuantumTrajectories.quantumtrajectories","page":"QuantumTrajectories","title":"ITensorsOpenSystems.QuantumTrajectories.quantumtrajectories","text":"quantumtrajectories(evolve::Function, jumpops, samples::Integer, ψ0::MPS, final_time::Real;\n                    time_step::Real=0.01, kwargs...) -> TrajectoriesResult\n\nArguments:\n\nevolve::Function: A function to evolve the state between jumps.\njumpops: An iterable of jump operators.\nsamples::Integer: The number of trajectories to generate.\nψ0::MPS: The initial state.\nfinal_time::Real: The final evolution time.\n\nKeyword Arguments:\n\ntime_step::Real: The evolution time step (default: 0.01).\nkwargs...: Additional keyword arguments for the evolution function.\n\nReturns:\n\nA TrajectoriesResult containing the trajectory data and corresponding sample times.\n\n\n\n\n\n","category":"function"},{"location":"api/QuantumTrajectories.html#ITensorsOpenSystems.QuantumTrajectories.sampletimes","page":"QuantumTrajectories","title":"ITensorsOpenSystems.QuantumTrajectories.sampletimes","text":"sampletimes(traj::TrajectoriesResult) -> Vector{Real}\n\nArguments:\n\ntraj::TrajectoriesResult: A trajectories result instance.\n\nReturns:\n\nThe vector of sample times stored in traj.\n\n\n\n\n\nsampletimes(traj::TrajectoriesResult, t1, t2) -> Vector{Real}\n\nArguments:\n\ntraj::TrajectoriesResult: A trajectories result instance.\nt1: The starting time.\nt2: The ending time.\n\nReturns:\n\nA filtered vector of sample times in traj that lie between t1 and t2 (inclusive).\n\n\n\n\n\n","category":"function"},{"location":"api/QuantumTrajectories.html#ITensorsOpenSystems.QuantumTrajectories.t_data","page":"QuantumTrajectories","title":"ITensorsOpenSystems.QuantumTrajectories.t_data","text":"t_data(traj::TrajectoriesResult, t::Real) -> Vector{MPS}\n\nArguments:\n\ntraj::TrajectoriesResult: A trajectories result instance.\nt::Real: A specific sample time.\n\nReturns:\n\nThe set of MPS corresponding to the sample time t.\n\nThrows:\n\nArgumentError if no trajectory data exists for time t.\n\n\n\n\n\nt_data(traj::TrajectoriesResult, t1::Real, t2::Real) -> Matrix{MPS}\n\nArguments:\n\ntraj::TrajectoriesResult: A trajectories result instance.\nt1::Real: The starting time.\nt2::Real: The ending time.\n\nReturns:\n\nA submatrix of raw_data corresponding to sample times between t1 and t2 (inclusive).\n\n\n\n\n\n","category":"function"},{"location":"api/QuantumTrajectories.html#ITensorsOpenSystems.QuantumTrajectories.trajectory","page":"QuantumTrajectories","title":"ITensorsOpenSystems.QuantumTrajectories.trajectory","text":"trajectory(evolve::Function, jumpops, ψ0::MPS, final_time::Real;\n           time_step::Real=0.01, sampletimes=0:time_step:final_time) -> Vector{MPS}\n\nCalculates the evolution of the states ψ0 along a single jump trajectory. The function  evolve(ψ,t1,t2) time evolves the state ψ from time t1 to time t2 with no jumps taking place. The jump operators, jumpops, are given as an iterable of opjects that can be  applyed to an MPS with ITensors.apply, i.e. MPOs, ITensors or vectors of ITensors.  The state is evolved from jumptimes[1] to jumptimes[end], checking if a jump should occure at each jumptime.\n\nArguments:\n\nevolve::Function: A function with signature evolve(ψ, t1, t2) that evolves ψ from time t1 to t2 without jumps.\njumpops: An iterable of jump operators.\nψ0::MPS: The initial state.\nfinal_time::Real: The final evolution time.\n\nKeyword Arguments:\n\ntime_step::Real: The evolution time step (default: 0.01).\nsampletimes: A collection of times at which the state is recorded (default: 0:time_step:final_time).\n\nReturns:\n\nReturns the state at each point in time along the trajectory in sampletimes\n\n##Example\n\nimport Dates:second,now\nusing ITensors\nusing ITensorTDVP\n\nN = 5\nJ = 1.0\nγ = 0.5\n\nindices = siteinds(\"S=1/2\",N)\n\nHop = OpSum()\n\n# Hermitian part of the Hamiltonian\nfor i = 1:(N-1)\n    Hop += J, \"Sz\", i, \"Sz\", i+1\nend\n\n# Non-Hermitian part of the Hamiltonian\nHop += -im*γ/2, \"Sp\", 1, \"Sm\", 1\nHop += -im*γ/2, \"Sm\", N, \"Sp\", N\n\nH = MPO(Hop,indices)\n\n# Define the jump operators corresponding\n# the non Hermitian part of H\njumpops = [γ * op(\"Sm\",1), γ * op(\"Sp\",N)]\n\nψ0 = randomMPS(indices)\n\n# We want to evolve the systems for 0 to tfinal, with potential jumps every tstep\ntfinal = 5\ntstep = 0.5\n\n#Seed the random number generator\nseed!(second(now()))\n\n# Final calculate the trajectory\ntrajectory_ψ = trajectory(jumpops, ψ0, 0:tstep,tfinal) do ψ, t1, t2\n    # Between jumps, evolve the system under H by TDVP\n    return tdvp(H,ψ,(t2-t1);cutoff=1e-7,normalize=false)\nend\n\nsee also: quantumtrajectories\n\n\n\n\n\n","category":"function"},{"location":"api/Vectorization.html#Documentation-for-ITensorsOpenSystems.Vectorization","page":"Vectorization","title":"Documentation for ITensorsOpenSystems.Vectorization","text":"","category":"section"},{"location":"api/Vectorization.html","page":"Vectorization","title":"Vectorization","text":"ITensorsOpenSystems.Vectorization.VectorizedDensityMatrix\nITensorsOpenSystems.Vectorization.add_jordan_wigner_strings\nITensorsOpenSystems.Vectorization.add_jordan_wigner_strings!\n\nITensorsOpenSystems.Vectorization.anticommutator\nITensorsOpenSystems.Vectorization.commutator\nITensorsOpenSystems.Vectorization.dissipator\nITensorsOpenSystems.Vectorization.fatsiteinds\nITensorsOpenSystems.Vectorization.full_anticommutator\nITensorsOpenSystems.Vectorization.full_commutator\nITensorsOpenSystems.Vectorization.full_dissipator\nITensorsOpenSystems.Vectorization.full_leftmultiply\nITensorsOpenSystems.Vectorization.full_rightmultiply\nITensorsOpenSystems.Vectorization.full_unvectorize_densitymatrix\nITensorsOpenSystems.Vectorization.operatorconj\nITensorsOpenSystems.Vectorization.trace\nITensorsOpenSystems.Vectorization.unvectorize_density_matrix!\nITensorsOpenSystems.Vectorization.vectorize_density_matrix!","category":"page"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.VectorizedDensityMatrix","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.VectorizedDensityMatrix","text":"VectorizedDensityMatrix(o::ITensors.MPO, inds::Vector{<:ITensors.Index})::VectorizedDensityMatrix\n\nDescription:     Construct a VectorizedDensityMatrix by vectorizing the given MPO using the provided indices.\n\n##args     - o::ITensors.MPO: The MPO representing a density matrix.     - inds::Vector{<:ITensors.Index}: The vectorized indices to be used. ##returns     - A VectorizedDensityMatrix obtained from o.\n\n\n\n\n\n","category":"type"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.add_jordan_wigner_strings","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.add_jordan_wigner_strings","text":"function addjordanwigner_strings(     ops::T,     inds::Vector{<:ITensors.Index};     kwargs..., )::T where {T<:Union{ITensors.Sum,ITensors.Scaled,ITensors.Prod{ITensors.Op}}}\n\nAdd Jordan–Wigner string operators to a product of ITensors operators.\n\nThis function modifies the given operator product ops in-place by inserting appropriate string operators between the factors. The insertion is based on the fermionic nature of the indices identified by the tag sitetag (default \"FermionVec\"), and the symbols used for creation (creationop) and annihilation (annihilationop) operators. A generic string operator (default \"F\") is used to build the overall Jordan–Wigner transformation. Internally, the function tracks fermionic sites and accumulates sets of string factors, then simplifies them by canceling adjacent terms where possible. Finally, the corresponding string operators are constructed and inserted into the original product.\n\nArguments\n\nops: An ITensors.Prod{ITensors.Op} representing the product of operator factors.\ninds: A vector of indices (subtypes of ITensors.Index) on which the operators act.\n\nKeyword Arguments\n\nsitetag: Tag used to identify fermionic sites within the indices (default \"FermionVec\").\ncreationop: String denoting the creation operator symbol (default \"Cdag\").\nannihilationop: String denoting the annihilation operator symbol (default \"C\").\nstringop: String representing the Jordan–Wigner string operator (default \"F\").\n\nReturns\n\nThe modified operator product ops with the Jordan–Wigner strings inserted.\n\n\n\n\n\n","category":"function"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.add_jordan_wigner_strings!","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.add_jordan_wigner_strings!","text":"add_jordan_wigner_strings!(ops::ITensors.Prod{ITensors.Op}, inds::Vector{<:ITensors.Index}; \n    sitetag::String = \"FermionVec\", \n    creationop::String = \"Cdag\", \n    annihilationop::String = \"C\", \n    stringop::String = \"F\",\n)::ITensors.Prod{ITensors.Op}\n\nfunction add_jordan_wigner_strings!(\n    ops::ITensors.Scaled,\n    inds::Vector{<:ITensors.Index};\n    kwargs...,\n    )::ITensors.Scaled\n\n\nfunction add_jordan_wigner_strings!(\n    ops::ITensors.Sum,\n    inds::Vector{<:ITensors.Index};\n    kwargs...,\n    )::ITensors.Sum\n\nfunction add_jordan_wigner_strings(\n    ops::T,\n    inds::Vector{<:ITensors.Index};\n    kwargs...,\n)::T where {T<:Union{ITensors.Sum,ITensors.Scaled,ITensors.Prod{ITensors.Op}}}\n\nAdd Jordan–Wigner string operators to a product of ITensors operators.\n\nThis function modifies the given operator product ops in-place by inserting appropriate string operators between the factors. The insertion is based on the fermionic nature of the indices identified by the tag sitetag (default \"FermionVec\"), and the symbols used for creation (creationop) and annihilation (annihilationop) operators. A generic string operator (default \"F\") is used to build the overall Jordan–Wigner transformation. Internally, the function tracks fermionic sites and accumulates sets of string factors, then simplifies them by canceling adjacent terms where possible. Finally, the corresponding string operators are constructed and inserted into the original product.\n\nArguments\n\nops: An ITensors.Prod{ITensors.Op} representing the product of operator factors.\ninds: A vector of indices (subtypes of ITensors.Index) on which the operators act.\n\nKeyword Arguments\n\nsitetag: Tag used to identify fermionic sites within the indices (default \"FermionVec\").\ncreationop: String denoting the creation operator symbol (default \"Cdag\").\nannihilationop: String denoting the annihilation operator symbol (default \"C\").\nstringop: String representing the Jordan–Wigner string operator (default \"F\").\n\nReturns\n\nThe modified operator product ops with the Jordan–Wigner strings inserted.\n\n\n\n\n\n","category":"function"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.anticommutator","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.anticommutator","text":"function anticommutator(opsum,fatsys,args...;kwargs...)\n\nConstructs an anticommutator operator and applies it to a state.\n\nThis function first computes the vectorized operator representation of the anticommutator  {q, ⋅} by calling anticommutatorapply(opsum), which returns an autoMPO object. It then uses  this representation to construct an ITensors.MPO object for the given system fatsys, passing  along any additional positional (args...) and keyword (kwargs...) arguments.\n\nArguments\n\nopsum: The operator sum for which the anticommutator {q, ⋅} is constructed.\nfatsys: The system  used in the MPO construction.\nargs...: Additional positional arguments forwarded to ITensors.MPO.\nkwargs...: Additional keyword arguments forwarded to ITensors.MPO.\n\nReturns\n\nAn ITensors.MPO representing the vectorized anticommutator operator {q, ⋅}.\n\nSee Also\n\ncommutator\n\n\n\n\n\n","category":"function"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.commutator","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.commutator","text":"function commutator(opsum, fatsys,args...;kwargs...)\n\nConstructs a commutator operator and applies it to a state.\n\nThis function first computes the vectorized operator representation of the commutator  [q, ⋅] by calling commutatorapply(opsum), which returns an autoMPO object. It then uses  this representation to construct an ITensors.MPO object for the given system fatsys,  passing along any additional arguments\n\nArguments\n\nopsum: The operator sum for which the commutator [q, ⋅] is constructed.\nfatsys: The system  used in the MPO construction.\nargs...: Additional positional arguments forwarded to ITensors.MPO.\nkwargs...: Additional keyword arguments forwarded to ITensors.MPO.\n\nReturns\n\nAn ITensors.MPO representing the vectorized commutator operator [q, ⋅].\n\nSee Also\n\nanticommutator\n\n\n\n\n\n","category":"function"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.dissipator","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.dissipator","text":"dissipator(opsum::Vector, fatsys)\nThis function computes the Lindblad dissipator for the array of op sums by \napplying the `lindbladdissipator` function element-wise. The resulting individual dissipators \nare then summed to obtain the total dissipator operator. Finally, an `ITensors.MPO` is constructed \nfrom this operator for the given system `fatsys`, with any additional positional (`args...`) and \nkeyword (`kwargs...`) arguments forwarded to `ITensors.MPO`.\n\n\n# Arguments\n- `opsum::Vector`: Vector of OpSums\n- `fatsys`: Vectorized system\n\n...\n\n\n\n\n\n","category":"function"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.fatsiteinds","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.fatsiteinds","text":"fatsiteinds(tag::String, N::Integer; kwargs...)\n\n# Arguments\n- `tag::String`: the name of the base space to vectorize\n- `N::Integer`: the number of site indices to create\n- `operators::Vector{String}`: (Optional) A vector of operators\n\n# Examples\n```\njulia> fatsys = fatsiteinds(\"S=1/2\", 3)\n3-element Vector{ITensors.Index{Int64}}:\n(dim=4|id=770|\"S=1/2Vec,Site,n=1\")\n(dim=4|id=704|\"S=1/2Vec,Site,n=2\")\n(dim=4|id=428|\"S=1/2Vec,Site,n=3\")\n\njulia> operators = [\"Z\", \"X\", \"Y\", (\"Sp\", \"Sm\")]\n4-element Vector{Any}:\n\"Z\"\n\"X\"\n\"Y\"\n(\"Sp\", \"Sm\")\n\njulia> fatsys = fatsiteinds(\"S=1/2\", 3, operators)\n3-element Vector{ITensors.Index{Int64}}:\n(dim=4|id=625|\"S=1/2Vec,Site,n=1\")\n(dim=4|id=31|\"S=1/2Vec,Site,n=2\")\n(dim=4|id=697|\"S=1/2Vec,Site,n=3\")\n```\n\nCreate an array of N physical site indices of type tag within an vectorized space. Keyword arguments can be used to specify quantum number conservation, see the space function corresponding to the site type tag for supported keyword arguments. These keyword arguments are passed through to the ITensors.siteinds function.\n\n\n\n\n\n","category":"function"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.full_anticommutator","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.full_anticommutator","text":"full_anticommutator(matrixType::Type, H, indices) -> matrixType\nfull_anticommutator(H, indices)\n\nConstructs the full matrix representation for the anticommutator operation induced by operator H.\n\nThis function calls MatrixConstruction.buildmatrix on anticommutatorapply(H) to generate a matrix that represents the anticommutator action ({H, ·} = H· + ·H) in the vectorized space defined by indices.\n\nArguments\n\nmatrixType::Type: (optional) The desired output matrix type.\nH: The operator for which the anticommutator is computed.\nindices: A vector of indices defining the Hilbert space basis.\n\nWhen matrixType is provided the resulting matrix will be of that type; otherwise, the default matrix type is used.\n\n\n\n\n\n","category":"function"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.full_commutator","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.full_commutator","text":"full_commutator(matrixType::Type, H, indices) -> matrixType\nfull_commutator(H, indices)\n\nConstructs the full matrix representation for the commutator operation induced by operator H.\n\nThis function calls MatrixConstruction.buildmatrix on commutatorapply(H) to generate a matrix that represents the commutator action ([H, ·] = H· - ·H) in the vectorized space defined by indices.\n\nArguments\n\nmatrixType::Type: (optional) The desired output matrix type.\nH: The operator for which the commutator is computed.\nindices: A vector of indices defining the Hilbert space basis.\n\nWhen matrixType is provided the resulting matrix will be of that type; otherwise, the default matrix type is used.\n\n\n\n\n\n","category":"function"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.full_dissipator","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.full_dissipator","text":"full_dissipator(matrixType::Type, A, indices) -> matrixType\nfull_dissipator(A, indices)\nfull_dissipator(A::Vector, indices)\n\nConstructs the full matrix representation of the Lindblad dissipator for operator(s) A.\n\nThe function calls MatrixConstruction.buildmatrix on lindbladdissipator(A) to generate a matrix representing the dissipative dynamics in the vectorized space defined by indices. When A is a vector of operators, their individual dissipators are summed (using an operator sum initializer).\n\nArguments\n\nmatrixType::Type: (optional) The desired output matrix type.\nA: The operator or vector of operators for which the dissipator is defined.\nindices: A vector of indices defining the Hilbert space basis.\n\nWhen matrixType is provided the resulting matrix will be of that type; otherwise, the default matrix type is used.\n\n\n\n\n\n","category":"function"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.full_leftmultiply","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.full_leftmultiply","text":"full_leftmultiply(matrixType::Type, H, indices) -> matrixType\nfull_leftmultiply(H, indices)\n\nConstructs the full matrix representation for left multiplication by operator H.\n\nThis function calls MatrixConstruction.buildmatrix on leftapply(H) to generate a matrix representing the left-multiplication action in the vectorized space defined by indices.\n\nArguments\n\nmatrixType::Type: (optional) The desired output matrix type.\nH: The operator whose left multiplication is to be represented.\nindices: A vector of indices defining the Hilbert space basis.\n\nWhen matrixType is provided the resulting matrix will be of that type; otherwise, the default matrix type is used.\n\n\n\n\n\n","category":"function"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.full_rightmultiply","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.full_rightmultiply","text":"full_rightmultiply(matrixType::Type, H, indices) -> matrixType\nfull_rightmultiply(H, indices)\n\nConstructs the full matrix representation for right multiplication by operator H.\n\nThis function calls MatrixConstruction.buildmatrix on rightapply(H) to generate a matrix representing the right-multiplication action in the vectorized space defined by indices.\n\nArguments\n\nmatrixType::Type: (optional) The desired output matrix type.\nH: The operator whose right multiplication is to be represented.\nindices: A vector of indices defining the Hilbert space basis.\n\nWhen matrixType is provided the resulting matrix will be of that type; otherwise, the default matrix type is used.\n\n\n\n\n\n","category":"function"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.full_unvectorize_densitymatrix","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.full_unvectorize_densitymatrix","text":"full_unvectorize_densitymatrix(ρ::Vector{T}, indices::Vector{<:ITensors.Index}) -> Matrix{T} where {T}\n\nConvert a vectorized density matrix ρ into its standard square matrix representation.\n\nThis function reconstructs a density matrix from its vectorized form. The dimensions of the Hilbert space are determined by processing each index in indices via basespace, ITensors.SiteType, and ITensors.space. For indices where the space is represented as a vector, the total dimension is obtained by summing over the second element of each subspace tuple. The product of these dimensions yields N, so that the density matrix should have N^2 elements. If the length of ρ does not equal N^2, an ArgumentError is thrown.\n\nArguments\n\nρ::Vector{T}: A vector containing the density matrix elements in a vectorized (flattened) form.\nindices::Vector{<:ITensors.Index}: A vector of indices defining the Hilbert space.\n\nReturns\n\nA Matrix{T} of size N × N, where N is the product of the Hilbert space dimensions.\n\nThrows\n\nArgumentError if length(ρ) != N^2.\n\n\n\n\n\n","category":"function"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.operatorconj","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.operatorconj","text":"operatorconj(rho::VectorizedDensityMatrix)::VectorizedDensityMatrix\n\nPerforms the hermitian conjugate on a vectorized density matrix\n\n\n\n\n\n","category":"function"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.trace","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.trace","text":"trace(o::Union{ITensors.MPS,VectorizedDensityMatrix})\n\nCalculates the trace of a vectorized density matrix by evaluating Tr(Id ρ).\n\n##args     - o::Union{ITensors.MPS,VectorizedDensityMatrix}: The vectorized density matrix as an MPS. ##returns     - The trace of ρ.\n\n\n\n\n\n","category":"function"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.unvectorize_density_matrix!","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.unvectorize_density_matrix!","text":"unvectorize_density_matrix!(\nm::VectorizedDensityMatrix,\nunvectorized_inds::Vector{<:ITensors.Index},\n)::ITensors.MPO\n\nDescription: Undoes the vectorization of a VectorizedDensityMatrix, in place, resulting in an MPO. The indices of the resulting MPO are given by unvectorized_inds\n\nargs\n\n- m::VectorizedDensityMatrix: The vectorized density matrix.\n- unvectorized_inds::Vector{<:ITensors.Index}: The target unvectorized indices.\n\nreturns\n\n- An ITensors.MPO representing the unvectorized density matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/Vectorization.html#ITensorsOpenSystems.Vectorization.vectorize_density_matrix!","page":"Vectorization","title":"ITensorsOpenSystems.Vectorization.vectorize_density_matrix!","text":"vectorize_density_matrix!(o::ITensors.MPO,vectorizedinds::Vector{<:ITensors.Index})::VectorizedDensityMatrix\n\nTreating the MPO as a density matrix, performs fat vectorization in place, resulting in a VectorizedDensityMatrix with indices given by vectorizedinds\n\nsee also: VectorizedDensityMatrix\n\n\n\n\n\n","category":"function"},{"location":"api/Vectorization.html","page":"Vectorization","title":"Vectorization","text":"basespace\nbuild_vectorized_space\nbuild_vectorized_space_name\nleftapply\nleftrightapply\nrightapply\nvectorization_sigil\nvectorizedop_sigil\nvectorizer\nvectorizer_input\nvectorizer_output","category":"page"},{"location":"developers/code_layout.html#code_layout","page":"code_layout","title":"Code layout","text":"","category":"section"},{"location":"developers/code_layout.html","page":"code_layout","title":"code_layout","text":"Cover the design decisions of the code and how we've laid out each submodule etc.","category":"page"},{"location":"api/SplitVectorization.html#Documentation-for-ITensorsOpenSystems.SplitVectorization","page":"SplitVectorization","title":"Documentation for ITensorsOpenSystems.SplitVectorization","text":"","category":"section"},{"location":"api/SplitVectorization.html","page":"SplitVectorization","title":"SplitVectorization","text":"ITensorsOpenSystems.SplitVectorization.VectorizedDensityMatrix\nITensorsOpenSystems.SplitVectorization.anticommutatorapply\nITensorsOpenSystems.SplitVectorization.commutatorapply\nITensorsOpenSystems.SplitVectorization.leftapply\nITensorsOpenSystems.SplitVectorization.leftrightapply\nITensorsOpenSystems.SplitVectorization.rightapply","category":"page"},{"location":"api/SplitVectorization.html#ITensorsOpenSystems.SplitVectorization.VectorizedDensityMatrix","page":"SplitVectorization","title":"ITensorsOpenSystems.SplitVectorization.VectorizedDensityMatrix","text":"VectorizedDensityMatrix(::Type{InsertIdentity}, initialmpo::MPO, site_indices)\n\nConstructs a vectorized density matrix representation from an unvectorized MPO state.\n\nThis function converts an MPO representing an unvectorized quantum state into its vectorized \ndensity matrix form by inserting appropriate identity and delta tensors. The conversion is \naccomplished by processing the MPO tensors and interleaving them with additional tensors based \non the provided `site_indices`. The transformation relies on matching and combining site and \nlink indices via ITensors\n\nThe function expects the number of vectorized site indices to be exactly twice the number of MPO tensors. \nIf the condition is not met, an `ArgumentError` is thrown.\n\n# Arguments\n- `::Type{InsertIdentity}`: A type indicator used to select the vectorization scheme.\n- `initialmpo::MPO`: The initial matrix product operator representing the unvectorized state.\n- `site_indices`: A vector of ITensors indices used in the transformation. Its length must equal `2 * n`,\n  where `n = length(initialmpo)`.\n\n# Returns\nA `VectorizedDensityMatrix` constructed from the modified tensor network, representing the \nvectorized density matrix of the input state.\n\n\n\n\n\n","category":"type"},{"location":"api/SplitVectorization.html#ITensorsOpenSystems.SplitVectorization.anticommutatorapply","page":"SplitVectorization","title":"ITensorsOpenSystems.SplitVectorization.anticommutatorapply","text":"anticommutatorapply(o)\n\nCompute the anticommutator action of an operator in the superfermion representation.\n\nThe anticommutator is defined as the sum of the left and right actions of o:\n\nArguments\n\no: The operator for which the anticommutator is computed.\n\nReturns\n\nAn operator representing the anticommutator action of o.\n\n\n\n\n\n","category":"function"},{"location":"api/SplitVectorization.html#ITensorsOpenSystems.SplitVectorization.commutatorapply","page":"SplitVectorization","title":"ITensorsOpenSystems.SplitVectorization.commutatorapply","text":"commutatorapply(o)\n\nCompute the commutator action of an operator in the superfermion representation.\n\nThe commutator is defined as the difference between the left and right actions of o:\n\nArguments\n\no: The operator for which the commutator is computed.\n\nReturns\n\nAn operator representing the commutator action of o.\n\n\n\n\n\n","category":"function"},{"location":"api/SplitVectorization.html#ITensorsOpenSystems.SplitVectorization.leftapply","page":"SplitVectorization","title":"ITensorsOpenSystems.SplitVectorization.leftapply","text":"leftapply(o)\n\nExtract the left action of an operator in the superfermion representation.\n\nThis function computes the left action by combining the operator o with the identity operator on the right. It is defined as:\n\n\n\n\n\n","category":"function"},{"location":"api/SplitVectorization.html#ITensorsOpenSystems.SplitVectorization.leftrightapply","page":"SplitVectorization","title":"ITensorsOpenSystems.SplitVectorization.leftrightapply","text":"leftrightapply(leftop::ITensors.Op, rightop::ITensors.Op) -> ITensors.Prod{Op}\nleftrightapply(leftop::ITensors.Prod{Op}, rightop::ITensors.Prod{Op}) -> ITensors.Prod{Op}\nleftrightapply(leftop::ITensors.Scaled, rightop::ITensors.Scaled) -> ITensors.Scaled\nleftrightapply(leftop::OpSum, rightop::OpSum) -> OpSum\nleftrightapply(leftop, rightop)\n\nConstruct a combined operator representing the left and right actions in the vectorized (superfermion) representation.\n\nThis function is overloaded for different types of operators:\n\nSingle Operators:\nSignature:   leftrightapply(leftop::ITensors.Op, rightop::ITensors.Op) -> ITensors.Prod{Op}\nBehavior:   For individual operators, the left operator's site indices are remapped as 2*s - 1 and the right operator's as 2*s. Their resulting vectorized forms are multiplied to yield a product operator.\nProduct Operators:\nSignature:   leftrightapply(leftop::ITensors.Prod{Op}, rightop::ITensors.Prod{Op}) -> ITensors.Prod{Op}\nBehavior:   If the two product operators have different lengths, the shorter is padded with identity operators (Op(\"Id\", 1)). The function then applies leftrightapply pairwise to the factors and reduces the result via multiplication.\nScaled Operators:\nSignature:   leftrightapply(leftop::ITensors.Scaled, rightop::ITensors.Scaled) -> ITensors.Scaled\nBehavior:   The scalar coefficients of the scaled operators are multiplied together, and leftrightapply is applied to their underlying operators.\nOperator Sums:\nSignature:   leftrightapply(leftop::OpSum, rightop::OpSum) -> OpSum\nBehavior:   The function distributes over all pairs of terms from the left and right OpSum objects, accumulating the results into a new sum.\nGeneric Fallback:\nSignature:   leftrightapply(leftop, rightop)\nBehavior:   If the input types do not match the above, both operands are converted to OpSum (by adding them to an empty OpSum) and processed accordingly.\n\nArguments\n\nleftop: The operator representing the left action.\nrightop: The operator representing the right action.\n\nReturns\n\nA combined operator representing the left-right action in the vectorized (superfermion) representation.\n\n\n\n\n\n","category":"function"},{"location":"api/SplitVectorization.html#ITensorsOpenSystems.SplitVectorization.rightapply","page":"SplitVectorization","title":"ITensorsOpenSystems.SplitVectorization.rightapply","text":"rightapply(o)\n\nExtract the right action of an operator in the superfermion representation.\n\nThis function computes the right action by combining the operator o with the identity operator on the left.\n\nArguments\n\no: The operator for which the right action is to be computed.\n\nReturns\n\nAn operator representing the right action of o.\n\nExample\n\nA = Op(\"A\", 1)\nR = rightapply(A)\n\n\n\n\n\n","category":"function"},{"location":"api/AnalyticSolutions.html#Documentation-for-ITensorsOpenSystems.AnalyticSolutions","page":"AnalyticSolutions","title":"Documentation for ITensorsOpenSystems.AnalyticSolutions","text":"","category":"section"},{"location":"api/AnalyticSolutions.html","page":"AnalyticSolutions","title":"AnalyticSolutions","text":"ITensorsOpenSystems.AnalyticSolutions.AbstractAnalyticChain\nITensorsOpenSystems.AnalyticSolutions.NotImplemented\nITensorsOpenSystems.AnalyticSolutions.SiteDissipation\nITensorsOpenSystems.AnalyticSolutions.UniformXXChain\nITensorsOpenSystems.AnalyticSolutions.appliedfield\nITensorsOpenSystems.AnalyticSolutions.bias\nITensorsOpenSystems.AnalyticSolutions.chainlength\nITensorsOpenSystems.AnalyticSolutions.coupling\nITensorsOpenSystems.AnalyticSolutions.current\nITensorsOpenSystems.AnalyticSolutions.dephasing\nITensorsOpenSystems.AnalyticSolutions.leftdissipation\nITensorsOpenSystems.AnalyticSolutions.magnetization\nITensorsOpenSystems.AnalyticSolutions.reversebias\nITensorsOpenSystems.AnalyticSolutions.rightdissipation","category":"page"},{"location":"api/AnalyticSolutions.html#ITensorsOpenSystems.AnalyticSolutions.AbstractAnalyticChain","page":"AnalyticSolutions","title":"ITensorsOpenSystems.AnalyticSolutions.AbstractAnalyticChain","text":"AbstractAnalyticChain\n\nAn abstract type for analytic chain models.\n\n\n\n\n\n","category":"type"},{"location":"api/AnalyticSolutions.html#ITensorsOpenSystems.AnalyticSolutions.NotImplemented","page":"AnalyticSolutions","title":"ITensorsOpenSystems.AnalyticSolutions.NotImplemented","text":"NotImplemented\n\nException thrown when an analytic solution is not implemented.\n\n\n\n\n\n","category":"type"},{"location":"api/AnalyticSolutions.html#ITensorsOpenSystems.AnalyticSolutions.SiteDissipation","page":"AnalyticSolutions","title":"ITensorsOpenSystems.AnalyticSolutions.SiteDissipation","text":"SiteDissipation\n\nHolds dissipation parameters for a site:\n\nf: bias parameter\nΓ: bath coupling strength\ndephase: dephasing parameter\n\n\n\n\n\n","category":"type"},{"location":"api/AnalyticSolutions.html#ITensorsOpenSystems.AnalyticSolutions.UniformXXChain","page":"AnalyticSolutions","title":"ITensorsOpenSystems.AnalyticSolutions.UniformXXChain","text":"UniformXXChain(N::Int, J::Float64, h::Float64; leftbias=0, leftbathcoupling=0, leftdephasing=0, rightbias=0, rightbathcoupling=0, rightdephasing=0)\n\nConstruct a new UniformXXChain with the specified parameters.\n\nArguments\n\nN::Int: The chain length (number of sites).\nJ::Float64: The coupling constant.\nh::Float64: The applied field.\n\nKeyword Args\n\nleftbias::Float64: The bias parameter for the left dissipation (default: 0).\nleftbathcoupling::Float64: The bath coupling for the left dissipation (default: 0).\nleftdephasing: The dephasing for the left dissipation (default: 0).\nrightbias::Float64: The bias parameter for the right dissipation (default: 0).\nrightbathcoupling::Float64: The bath coupling for the right dissipation (default: 0).\nrightdephasing::Float64: The dephasing for the right dissipation (default: 0).\n\nReturns\n\nA new instance of UniformXXChain.\n\n\n\n\n\n","category":"type"},{"location":"api/AnalyticSolutions.html#ITensorsOpenSystems.AnalyticSolutions.appliedfield","page":"AnalyticSolutions","title":"ITensorsOpenSystems.AnalyticSolutions.appliedfield","text":"appliedfield(c::UniformXXChain) -> Float64\n\nArguments\n\nc::UniformXXChain: An instance of UniformXXChain.\n\nReturns\n\nThe applied field h of the chain c.\n\n\n\n\n\n","category":"function"},{"location":"api/AnalyticSolutions.html#ITensorsOpenSystems.AnalyticSolutions.bias","page":"AnalyticSolutions","title":"ITensorsOpenSystems.AnalyticSolutions.bias","text":"bias(s::SiteDissipation) -> Float64\n\nArguments\n\ns::SiteDissipation: A site dissipation configuration.\n\nReturns\n\nThe bias value f of the site dissipation.\n\n\n\n\n\n","category":"function"},{"location":"api/AnalyticSolutions.html#ITensorsOpenSystems.AnalyticSolutions.chainlength","page":"AnalyticSolutions","title":"ITensorsOpenSystems.AnalyticSolutions.chainlength","text":"chainlength(c::UniformXXChain) -> Int64\n\nArguments\n\nc::UniformXXChain: An instance of UniformXXChain.\n\nReturns\n\nThe chain length (number of sites) contained in c.\n\n\n\n\n\n","category":"function"},{"location":"api/AnalyticSolutions.html#ITensorsOpenSystems.AnalyticSolutions.coupling","page":"AnalyticSolutions","title":"ITensorsOpenSystems.AnalyticSolutions.coupling","text":"coupling(s::SiteDissipation) -> Float64\n\nArguments\n\ns::SiteDissipation: A site dissipation configuration.\n\nReturns\n\nThe coupling strength Γ of the site dissipation.\n\n\n\n\n\ncoupling(c::UniformXXChain) -> Float64\n\nArguments\n\nc::UniformXXChain: An instance of UniformXXChain.\n\nReturns\n\nThe coupling constant J of the chain c.\n\n\n\n\n\n","category":"function"},{"location":"api/AnalyticSolutions.html#ITensorsOpenSystems.AnalyticSolutions.current","page":"AnalyticSolutions","title":"ITensorsOpenSystems.AnalyticSolutions.current","text":"current(c::UniformXXChain) -> Float64\n\nCalculate and return the analytic current for the chain c.\n\nArguments\n\nc::UniformXXChain: An instance of UniformXXChain.\n\nReturns\n\nThe computed current as a Float64.\n\nThrows\n\nNotImplemented if:\nThe applied field is nonzero.\nThe dissipation parameters for the left and right ends are asymmetric.\nNonzero dephasing is present at either end.\n\n\n\n\n\n","category":"function"},{"location":"api/AnalyticSolutions.html#ITensorsOpenSystems.AnalyticSolutions.dephasing","page":"AnalyticSolutions","title":"ITensorsOpenSystems.AnalyticSolutions.dephasing","text":"dephasing(s::SiteDissipation) -> Float64\n\nArguments\n\ns::SiteDissipation: A site dissipation configuration.\n\nReturns\n\nThe dephasing parameter of the site dissipation.\n\n\n\n\n\n","category":"function"},{"location":"api/AnalyticSolutions.html#ITensorsOpenSystems.AnalyticSolutions.leftdissipation","page":"AnalyticSolutions","title":"ITensorsOpenSystems.AnalyticSolutions.leftdissipation","text":"leftdissipation(c::UniformXXChain) -> SiteDissipation\n\nArguments\n\nc::UniformXXChain: An instance of UniformXXChain.\n\nReturns\n\nThe SiteDissipation parameters for the left end of the chain.\n\n\n\n\n\n","category":"function"},{"location":"api/AnalyticSolutions.html#ITensorsOpenSystems.AnalyticSolutions.magnetization","page":"AnalyticSolutions","title":"ITensorsOpenSystems.AnalyticSolutions.magnetization","text":"magnetization(c::UniformXXChain) -> Vector{Float64}\n\nCalculate and return the analytic magnetization profile for the chain c.\n\nArguments\n\nc::UniformXXChain: An instance of UniformXXChain.\n\nReturns\n\nA vector containing the magnetization profile.\n\nThrows\n\nNotImplemented if:\nThe applied field is nonzero.\nThe dissipation parameters for the left and right ends are asymmetric.\nNonzero dephasing is present at either end.\n\n\n\n\n\n","category":"function"},{"location":"api/AnalyticSolutions.html#ITensorsOpenSystems.AnalyticSolutions.reversebias","page":"AnalyticSolutions","title":"ITensorsOpenSystems.AnalyticSolutions.reversebias","text":"reversebias(s::SiteDissipation) -> SiteDissipation\n\nArguments\n\ns::SiteDissipation: A site dissipation configuration.\n\nReturns\n\nA new SiteDissipation with the bias reversed (i.e. 1 - s.f), while keeping the coupling and dephasing unchanged.\n\n\n\n\n\n","category":"function"},{"location":"api/AnalyticSolutions.html#ITensorsOpenSystems.AnalyticSolutions.rightdissipation","page":"AnalyticSolutions","title":"ITensorsOpenSystems.AnalyticSolutions.rightdissipation","text":"rightdissipation(c::UniformXXChain) -> SiteDissipation\n\nArguments\n\nc::UniformXXChain: An instance of UniformXXChain.\n\nReturns\n\nThe SiteDissipation parameters for the right end of the chain.\n\n\n\n\n\n","category":"function"},{"location":"developers/guide.html#ITensorsOpenSystems.jl-Developer-Guide","page":"guide","title":"ITensorsOpenSystems.jl Developer Guide","text":"","category":"section"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"This guide will help you get setup with all the tools you need to contribute to the development of the package. We'll assume you have Julia >= 1.9 installed, if you haven't, please see the installation guide.","category":"page"},{"location":"developers/guide.html#Development-environment","page":"guide","title":"Development environment","text":"","category":"section"},{"location":"developers/guide.html#Clone-the-repo","page":"guide","title":"Clone the repo","text":"","category":"section"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"For this section we'll assume you've been given access to the ITensorsOpenSystems.jl repository.","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"First clone the repository","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"$ git clone git@github.com:ITensor-opensystems/ITensorsOpenSystems.jl.git","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"Then move into the package","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"$ cd ITensorsOpenSystems.jl","category":"page"},{"location":"developers/guide.html#Running-the-tests","page":"guide","title":"Running the tests","text":"","category":"section"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"Now you're setup you can try running the tests to make sure everthing required is installed and the tests pass on your system","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"First we'll start the Julia REPL, activate the package manager and activate the package","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"$ julia\njulia> ]\n(@v1.10) pkg> activate .\n    Activating project at `~/Documents/ITensorsOpenSystems`\n\n(ITensorsOpenSystems) pkg>","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"Now you're ready to run the tests","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":" (ITensorsOpenSystems) pkg> test","category":"page"},{"location":"developers/guide.html#Install-in-dev-mode","page":"guide","title":"Install in dev mode","text":"","category":"section"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"As you'll be modifying a local copy of the package during development you can install the package in dev mode. Make sure your terminal working directory is the root of the ITensorsOpenSystems.jl repository and then run","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"$ julia\njulia> ]\n(@v1.10) pkg> dev .","category":"page"},{"location":"developers/guide.html#Pre-commit-(optional)","page":"guide","title":"Pre-commit (optional)","text":"","category":"section"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"We use pre-commit to ensure commits meet the standards we expect. This tool runs some pre-commit hooks to run linting and formatting checks on the changes being made.","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"To install the pre-commit hooks run","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"$ pre-commit install\npre-commit installed at .git/hooks/pre-commit","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"On the first commit after install you'll see messages telling you the pre-commit environment is being initialized, this will only happen once.","category":"page"},{"location":"developers/guide.html#Bypassing-pre-commit","page":"guide","title":"Bypassing pre-commit","text":"","category":"section"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"If you find that pre-commit is causing issues you can bypass the hook by passing the -n flag when making a commit.","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"$ git commit -n -m \"commit message\"","category":"page"},{"location":"developers/guide.html#Using-Revise.jl","page":"guide","title":"Using Revise.jl","text":"","category":"section"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"The Revise.jl package allows changes you've made to the source code to become available in you current Julia session. Without Revise you'll need to restart your Julia session each time you make changes. Install the package using the package manager.","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"julia> ]\n(v1.10) pkg> add Revise","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"When you start a Julia REPL during development the first using statement should be using Revise. This will then enable Revise for the session. Alternatively if you're on Linux/macOS you can make sure Revise is started at the beginning of each Julia session by running","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"mkdir -p ~/.julia/config/ && echo \"using Revise\" >> ~/.julia/config/startup.jl","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"For more information see the documentation.","category":"page"},{"location":"developers/guide.html#Contributing","page":"guide","title":"Contributing","text":"","category":"section"},{"location":"developers/guide.html#Tutorial-driven-development","page":"guide","title":"Tutorial driven development","text":"","category":"section"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"As we've developed ITensorsOpenSystems.jl we've worked with tutorial driven development approach. This means that for each piece of functionality we want to add to the package we first write a tutorial. To do this we write out the function calls we'd like to make and the objects we expect to be returned.","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"It doesn't matter that those functions don't exist yet, we'll create them once we'll finished a first pass of the tutorial. The interface to each function doesn't have to be perfect on the first pass, write an almost complete tutorial and then start writing the code. As you write the code you'll realise some of the tutorial will need changing.","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"Work in an iterative way, improving the tutorial and code with each iteration. Once you've completed the code you'll have a complete tutorial that covers all of the new functionality. There shouldn't be any functionality in the project that isn't covered by a tutorial as users have no way of knowing this functionality exists.","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"We've tried to organise ITensorsOpenSystems.jl in an easy to understand way. To better understand why the code is organised as it is please first read our code layout guide. We'll now cover the process of adding or modifying functionality from start to finish.","category":"page"},{"location":"developers/guide.html#Feature-branches","page":"guide","title":"Feature branches","text":"","category":"section"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"As we develop ITensorsOpenSystems we use feature branches as we develop new functionality. Each piece of work should have a GitHub issue associated with it. This makes it easy to track work and discuss design ideas and track progress of the work. Let's create a new feature branch for some work described in issue 42.","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"We use the devel branch as our development branch, we'll first check it out and pull any recent changes.","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"$ git checkout devel\n$ git pull","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"Now we're ready to create our branch","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"$ git checkout -b Iss42/Foo","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"Here we've created a branch called Iss42/Foo. Starting the branch name with the issue number followed by a couple of descriptive words helps future us and our collaborators understand what's happening where.","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"Now we've created the branch make your commits, merging in the devel if the branch is longer lived, this helps prevent complicated merge conflicts further down the line.","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"Once you've finished the feature open a pull request on the ITensorsOpenSystems.jl repository and request a code review.","category":"page"},{"location":"developers/guide.html#Adding-documentation","page":"guide","title":"Adding documentation","text":"","category":"section"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"All our documentation is contained in Markdown files in a folder structure expected by Documenter.jl.","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"docs/\n    src/\n        getting_started/            <- tutorials for users and developers\n            installation.md         <- getting ITensorsOpenSystems.jl installed\n            ...\n        tutorials/                  <- in-depth end-to-end tutorials covering functionality\n            tutorial1.md            <- Tutorial covering creating an open quantum system\n            ...\n        AnalyticSolutions.md        <- API documentation for ChainMappings submodule\n        ChainMappings.md            <- API documentation for ChainMappings submodule\n        Superfermions.md            <- API documentation for Superfermions submodule\n        SplitVectorization.md       <- API documentation for SplitVectorization submodule\n        Vectorization.md            <- API documentation for Vectorization submodule\n        ...\n    .gitignore                      <- tell Git to ignore built documentation\n    make.jl                         <- Julia script containing build instructions\n    Project.toml                    <- Contains libraries used to create documentation","category":"page"},{"location":"developers/guide.html#Tutorials","page":"guide","title":"Tutorials","text":"","category":"section"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"If you're adding new functionality, create a new tutorial file in the tutorials folder.","category":"page"},{"location":"developers/guide.html#API-changes","page":"guide","title":"API changes","text":"","category":"section"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"If you're adding functions or objects that will be exported from the package you'll need add these to the API documentation in the file for that module. Let's add a new function to the Superfermions module.","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"Superfermions.rightapply\nSuperfermions.leftapply\nSuperfermions.my_new_function\n...","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"The @docs tag in the Markdown file is part of the syntax used by Documenter.jl when building the documentation. You can read more about that in the documentation.","category":"page"},{"location":"developers/guide.html#Building-the-documentation","page":"guide","title":"Building the documentation","text":"","category":"section"},{"location":"developers/guide.html#Updating-make.jl","page":"guide","title":"Updating make.jl","text":"","category":"section"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"If you've added any new files to the documentation you'll need to update the makedocs call in the make.jl file. This tells Documenter where to look for the API documentation and tutorials.","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"For example, to make Documenter.jl aware of a new tutorial you'll need to add it to the Tutorials section. Note that here we use ... to denote lines in the file not shown here.","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"...\n\nmakedocs(\n    sitename = \"ITensorsOpenSystems\",\n    format = Documenter.HTML(prettyurls = get(ENV, \"CI\", nothing) == \"true\"),\n    modules = [ITensorsOpenSystems],\n    pages = Any[\n        \"Introduction\" => \"index.md\",\n        \"API\" => [\n            \"AnalyticSolutions\" => \"AnalyticSolutions.md\",\n            \"GlobalFunctionApproximation\" => \"GlobalFunctionApproximation.md\",\n            ...\n        ],\n        \"Tutorials\" => [\n            \"Open Spin Systems\" => \"tutorials/tutorial1.md\",\n            \"My new tutorial\" => \"tutorials/my_tutorial.md\",\n        ]],\n)\n\n...\n","category":"page"},{"location":"developers/guide.html#Build","page":"guide","title":"Build","text":"","category":"section"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"We're now ready to build the documentation. Ensure your terminal working directory is the docs folder and then run","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"$ julia --project make.jl","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"This will build the documentation HTML files and write these to a build folder. Once it's finished you can open the documentation at build/index.html.","category":"page"},{"location":"developers/guide.html#Dealing-with-errors","page":"guide","title":"Dealing with errors","text":"","category":"section"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"You may encounter errors such as","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"[ Info: SetupBuildDirectory: setting up build directory.\n[ Info: Doctest: running doctests.\n[ Info: ExpandTemplates: expanding markdown templates.\n[ Info: CrossReferences: building cross-references.\n[ Info: CheckDocument: running document checks.\n┌ Error: 1 docstring not included in the manual:\n│\n│     ITensorsOpenSystems.MatrixConstruction.new_function :: Tuple{Any}\n│\n│ These are docstrings in the checked modules (configured with the modules keyword)\n│ that are not included in canonical @docs or @autodocs blocks.\n└ @ Documenter ~/.julia/packages/Documenter/2OZOh/src/utilities/utilities.jl:44","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"This means we've forgotten to add the MatrixConstruction.new_function function to the list of functions in the MatrixConstruction.md API documentation file.","category":"page"},{"location":"developers/guide.html#Writing-tests","page":"guide","title":"Writing tests","text":"","category":"section"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"We need to make sure that each function we add to the package behaves as we expect it to. We use the ReTestItems.jl package to run our tests. See their documentation for information on how to write tests using that framework.","category":"page"},{"location":"developers/guide.html#Pull-request-and-code-review","page":"guide","title":"Pull request and code review","text":"","category":"section"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"GitHub allows use to easily review code that's being added to the project. We've setup the repository to only allow merging of changes if they've passed a code review and have been given approval by a maintainer. This is an important process to ensure that","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"code is understood by others\ncode adheres to the standards expected\ncode is well documented","category":"page"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"This isn't meant to be a hurdle to contributing, it helps everyone better understand new features.","category":"page"},{"location":"developers/guide.html#GitHub-Actions-CI/CD","page":"guide","title":"GitHub Actions CI/CD","text":"","category":"section"},{"location":"developers/guide.html","page":"guide","title":"guide","text":"As part of the pull request the GitHub Actions runners will run some checks to make sure the code meets the standards we expect and that all the tests pass. See the results of our GitHub Actions runners here.","category":"page"},{"location":"api/HamiltonianBuilding.html#Documentation-for-ITensorsOpenSystems.HamiltonianBuilding","page":"HamiltonianBuilding","title":"Documentation for ITensorsOpenSystems.HamiltonianBuilding","text":"","category":"section"},{"location":"api/HamiltonianBuilding.html","page":"HamiltonianBuilding","title":"HamiltonianBuilding","text":"ITensorsOpenSystems.HamiltonianBuilding.build_from_matrix\nITensorsOpenSystems.HamiltonianBuilding.insert_ancilla\nITensorsOpenSystems.HamiltonianBuilding.insert_sites","category":"page"},{"location":"api/HamiltonianBuilding.html#ITensorsOpenSystems.HamiltonianBuilding.build_from_matrix","page":"HamiltonianBuilding","title":"ITensorsOpenSystems.HamiltonianBuilding.build_from_matrix","text":"build_from_matrix(coefficents::AbstractMatrix, leftops, rightops,offset::Integer=0)::OpSum\n\nArguments\n\ncoefficents::AbstractMatrix: Matrix of Coefficients\nleftops, rightops: Left and Right Operators om site i\n(optional) offset can be given which shifts the index of the first site by the given amount.\n\nReturns\n\nOpSum - an AutoMPO representation of the expresion\n\nConstructs an AutoMPO representation of the expresion Σ{i,j} M{i,j} Li Rj where Li and Ri are operators on site i and M_{i,j} is a matrix of coefficents\n\nThe operators can be spesifed either as stings or as an iterable of strings. If an iterable is given, then the result is the product of the operators in the iterable, all at the same site, in the given order.\n\nThe leftops, corresponding to the first index of the matrix, are always placed to the right of the rightops, corresponding to the second. \n\nWhen considering a subset of sites, which does not start at the first site, an offset can be given which shifts the index of the first site by the given amount.\n\nExamples\n\n# Build coefficent matrix\nm = [0.0 1.0\n     1.0 0.0]\n\n\n# Build hopping term\nhopping_ops = build_from_matrix(m,\"Cdag\",\"C\")\n\n# Build interaction term\nu = 0.1\ninteraction_ops = build_from_matrix(u * m, [\"Cdag\",\"C\"], [\"Cdag\".\"C\"])\n\n# Combine into a single Hamiltonian and build MPO\nh = OpSum()\nh += hopping_ops\nh += interaction_ops\n\nindices = siteinds(\"Fermion\",2)\nH = MPO(h,indices)\n\n\n\n\n\n","category":"function"},{"location":"api/HamiltonianBuilding.html#ITensorsOpenSystems.HamiltonianBuilding.insert_ancilla","page":"HamiltonianBuilding","title":"ITensorsOpenSystems.HamiltonianBuilding.insert_ancilla","text":"insert_ancilla(ops,system_sites)\n\nShifts positions of operators in autoMPO object ops to account for an ancilla site being inserted directly after  each site in system_sites.\n\nsee also insert_sites\n\n\n\n\n\n","category":"function"},{"location":"api/HamiltonianBuilding.html#ITensorsOpenSystems.HamiltonianBuilding.insert_sites","page":"HamiltonianBuilding","title":"ITensorsOpenSystems.HamiltonianBuilding.insert_sites","text":"insert_sites(ops,sites)\n\nShifts the postions of the operators in autoMPO object ops to take account of additional sites being inserted at the positions given in sites. The the positions given in sites refer to positions in the order before any insertions are made.\n\n#Example\n\nops = OpSum()\nops += \"C\", 3, \"Cdag\",5\nops += 2.0, \"N\", 6\n\n# Add extra sites at positions 1,4 and 6, so that site 3 must be moved\n# 1 space to the right (to account for the addition at site 1), site\n# 5 must be moved over 2 places (for the additions at sites 1 and 4)\n# and position 6 must move to site 9 to account for the additions \n# at sites 1, 5 and the new 6.\ninsert_sites(ops,[1,4,6])\n> sum(\n    1.0 C(4,) Cdag(7)\n    2.0 N(9,)\n)\n\nsee also insert_ancilla\n\n\n\n\n\n","category":"function"},{"location":"api/private/_VectorizationCore.html#Documentation-for-ITensorsOpenSystems._VectorizationCore","page":"_VectorizationCore","title":"Documentation for ITensorsOpenSystems._VectorizationCore","text":"","category":"section"},{"location":"api/private/_VectorizationCore.html","page":"_VectorizationCore","title":"_VectorizationCore","text":"ITensorsOpenSystems._VectorizationCore.VectorizationError\nITensorsOpenSystems._VectorizationCore.basespace\nITensorsOpenSystems._VectorizationCore.build_vectorized_space\nITensorsOpenSystems._VectorizationCore.build_vectorized_space_name\nITensorsOpenSystems._VectorizationCore.leftapply\nITensorsOpenSystems._VectorizationCore.leftrightapply\nITensorsOpenSystems._VectorizationCore.rightapply\nITensorsOpenSystems._VectorizationCore.vectorization_sigil\nITensorsOpenSystems._VectorizationCore.vectorizedop_sigil\nITensorsOpenSystems._VectorizationCore.vectorizer\nITensorsOpenSystems._VectorizationCore.vectorizer_input\nITensorsOpenSystems._VectorizationCore.vectorizer_output","category":"page"},{"location":"api/private/_VectorizationCore.html#ITensorsOpenSystems._VectorizationCore.VectorizationError","page":"_VectorizationCore","title":"ITensorsOpenSystems._VectorizationCore.VectorizationError","text":"Struct for error message with message and site type of the failed vectorization\n\n\n\n\n\n","category":"type"},{"location":"api/private/_VectorizationCore.html#ITensorsOpenSystems._VectorizationCore.basespace","page":"_VectorizationCore","title":"ITensorsOpenSystems._VectorizationCore.basespace","text":"basespace(idx::ITensors.Index)::String\n\nGiven an index for a vectorized site, returns the name of the site space prior to vectorization\n\n\n\n\n\nbasespace(m::Union{ITensors.MPS,ITensors.MPO})::String\n\nGiven a Union of ...\n\n\n\n\n\n","category":"function"},{"location":"api/private/_VectorizationCore.html#ITensorsOpenSystems._VectorizationCore.build_vectorized_space","page":"_VectorizationCore","title":"ITensorsOpenSystems._VectorizationCore.build_vectorized_space","text":"Builds the vectorized space for a given site type.\n\n# Arguments\n- `basespace_name::String`: the name of the base space to vectorize\n- `operators::Vector{String}`: A vector of operators\n- `conserve_qns::Bool`: Should quantum numbers be conserved\n- `conserve_qns_options::String`: If we are to conserve quantum numbers, how to do so, \n                                    valid options are \"difference\" or \"independent\"\n- `additional_parameters::Union{Nothing,Vector{Pair{Symbol,<:Function}}}`: Used to \n                                    vectorize spaces with variable dimension. Expects a\n                                    list of pairs of keywords and functions which \n                                    take in a vectorized index and return the value\n                                    of the keyword used to create them\n# Examples\n```jldoctest\njulia> build_vectorized_space(\"S=1/2\")\n\njulia> siteind(\"S=1/2Vec\")\n(dim=4|id=145|\"S=1/2Vec,Site\")\n```\n\n\n\n\n\n","category":"function"},{"location":"api/private/_VectorizationCore.html#ITensorsOpenSystems._VectorizationCore.build_vectorized_space_name","page":"_VectorizationCore","title":"ITensorsOpenSystems._VectorizationCore.build_vectorized_space_name","text":"build_vectorized_space_name(tag::String)\n\nCreate the vectorized space name\n\n\n\n\n\n","category":"function"},{"location":"api/private/_VectorizationCore.html#ITensorsOpenSystems._VectorizationCore.leftapply","page":"_VectorizationCore","title":"ITensorsOpenSystems._VectorizationCore.leftapply","text":"leftapply(op)\n\nConstructs the vectorized operator corresponding to left multiplication\nby `op` as an autoMPO object\n\nsee also: `rightapply`, `leftrightapply`\n\n\n\n\n\n","category":"function"},{"location":"api/private/_VectorizationCore.html#ITensorsOpenSystems._VectorizationCore.leftrightapply","page":"_VectorizationCore","title":"ITensorsOpenSystems._VectorizationCore.leftrightapply","text":"leftrightapply(leftop,rightop)\nTakes a pair of autoMPO objects on the unvectorized space and constructs the \nautoMPO object on the vectorized space corresponding to left multiplying the density\nmatrix by `leftop` and right multiplying it by `rightop`\n\n# Example\n```julia-repl\njulia> leftop, rightop = OpSum(),OpSum()\njulia>leftop += \"σx\", 1\njulia>rightop += \"σz\", 1\n\njulia>leftrightapply(leftop,rightop)\nsum(\n    1.0, \"σzᵀ⊗σx\", 1\n)\n```\nsee also: `leftapply`, `rightapply`, `commutatorapply`, `commutator`, `lindbladdissipator`, `dissipator`\n\n\n\n\n\n","category":"function"},{"location":"api/private/_VectorizationCore.html#ITensorsOpenSystems._VectorizationCore.rightapply","page":"_VectorizationCore","title":"ITensorsOpenSystems._VectorizationCore.rightapply","text":"rightapply(op)\n\nConstructs the vectorized operator corresponding to right multiplication\nby `op` as an autoMPO object\n\nsee also: `leftapply`, `leftrightapply`\n\n\n\n\n\n","category":"function"},{"location":"api/private/_VectorizationCore.html#ITensorsOpenSystems._VectorizationCore.vectorization_sigil","page":"_VectorizationCore","title":"ITensorsOpenSystems._VectorizationCore.vectorization_sigil","text":"vectorization_sigil\n\nUsed in site tags to designate the vectorised version of a given site space i.e \"Fermion\" vectorizes to \"FermionVec\", \"S=1/2\" vectorizes to \"S=1/2Vec\",  etc. \n\n\n\n\n\n","category":"constant"},{"location":"api/private/_VectorizationCore.html#ITensorsOpenSystems._VectorizationCore.vectorizedop_sigil","page":"_VectorizationCore","title":"ITensorsOpenSystems._VectorizationCore.vectorizedop_sigil","text":"vectorizedop_sigil\n\nUsed in op names to denote that the op is the vectorized product of two ops on the base space. For example \"σxᵀ⊗σy would denote the vectorized operator for left multiplying with σy and right multiplying with σx\n\n\n\n\n\n","category":"constant"},{"location":"api/private/_VectorizationCore.html#ITensorsOpenSystems._VectorizationCore.vectorizer","page":"_VectorizationCore","title":"ITensorsOpenSystems._VectorizationCore.vectorizer","text":"vectorizer(_dumby;kwargs...)\nvectorizer(space::String;kwargs...)\n\n\nReturns the vectorization tensor, which maps a pair of site indices\nin the vectorized space (with oposite directions), to a single index\nin the vectorized space.\n\nIt is recomended to always use this when combining or separating site indices\nto esure that a consitent convention for how the different indices correspond\nis maintained\n\nIf the space has conserved quantum numbers the index can be returned with or without\nthem using the `conserve_qns` keyword.\n\nFor spaces with variable dimension, additional keywords can be provided to spesify\nthe dimension of the index returned. In these cases the `sample_idx` keyword can\nalso used. This expects a vectorized index and adds the keywords used to create that\nindex to the ones passed directly to the function\n\n# Example\n```\n# We create some local site indices and some corrisponding\n# vectoprized indices\ns = siteinds(\"S=1/2\", 2)\nsv = siteinds(\"S=1/2Vec\",2)\n\n# We create a tensor using those local indices\nt = op(\"Sz\", s[1])\n\n# We set the indices on t to match those of the vectorization\n# tensor\nt *= delta(vectorizer_input(\"S=1/2\"),s[1])\nt *= delta(vectorizer_input(\"S=1/2\")', s[1]')\n\n# We combine the indices on t into a single \n# vecotorized index\nt *= vectorizer(\"S=1/2\")\n\n# We set the single index on t to be one of\n# our previously created vectorized indices\nt *= delta(vectorizer_output(\"s=1/2\"),sv[1])\n```\n\nsee also: `vectorizer_input`, `vectorizer_output`\n\n\n\n\n\n","category":"function"},{"location":"api/private/_VectorizationCore.html#ITensorsOpenSystems._VectorizationCore.vectorizer_input","page":"_VectorizationCore","title":"ITensorsOpenSystems._VectorizationCore.vectorizer_input","text":"vectorizer_input(_dumby;kwargs...)\nvectorizer_input(space::String;kwargs...)\n\n\n\nReturns the input (unvectorized) indices of the vectorization tensor.\nThe vectorization tensor has two copies of this index, one primed\n(directed in if there are conserved quantum numbers) corresponding\nto the left hand index of the unvectorized density matrix and one\nunprimed (directed out if there are conserved quantum numbers)\ncorresponding to the right hand index of the unvectorized desnity\nmatrix. \n\nIf the space has conserved quantum numbers the index can be returned\nwith or without them using the `conserve_qns` keyword.\n\nFor spaces with variable dimension, additional keywords can be provided\nto spesify the dimension of the index returned. In these cases the\n`sample_idx` keyword can also used. This expects a vectorized index and \nadds the keywords used to create that index to the ones passed directly \nto the function\n\n\n# Example\n```\n# We create some local site indices and some corrisponding\n# vectoprized indices\ns = siteinds(\"S=1/2\", 2)\nsv = siteinds(\"S=1/2Vec\",2)\n\n# We create a tensor using those local indices\nt = op(\"Sz\", s[1])\n\n# We set the indices on t to match those of the vectorization\n# tensor\nt *= delta(vectorizer_input(\"S=1/2\"),s[1])\nt *= delta(vectorizer_input(\"S=1/2\")', s[1]')\n\n# We combine the indices on t into a single \n# vecotorized index\nt *= vectorizer(\"S=1/2\")\n\n# We set the single index on t to be one of\n# our previously created vectorized indices\nt *= delta(vectorizer_output(\"s=1/2\"),sv[1])\n```\n\nsee also: `vectorizer`, `vectorizer_output`\n\n\n\n\n\n","category":"function"},{"location":"api/private/_VectorizationCore.html#ITensorsOpenSystems._VectorizationCore.vectorizer_output","page":"_VectorizationCore","title":"ITensorsOpenSystems._VectorizationCore.vectorizer_output","text":"vectorizer_output(_dumby;kwargs...)\nvectorizer_output(space::String;kwargs...)\n\n\nReturns the output (vectorized) indices of the vectorization tensor.\nThe vectorization tensor has one unprimed (outfacing if quantum numbers are conserved)\ncopy of this index, corresponding to the vectorized index. \n\nIf the space has conserved quantum numbers the index can be returned\nwith or without them using the `conserve_qns` keyword.\n\nFor spaces with variable dimension, additional keywords can be provided\nto spesify the dimension of the index returned. In these cases the\n`sample_idx` keyword can also used. This expects a vectorized index and \nadds the keywords used to create that index to the ones passed directly \nto the function\n\n# Example\n```\n# We create some local site indices and some corrisponding\n# vectoprized indices\ns = siteinds(\"S=1/2\", 2)\nsv = siteinds(\"S=1/2Vec\",2)\n\n# We create a tensor using those local indices\nt = op(\"Sz\", s[1])\n\n# We set the indices on t to match those of the vectorization\n# tensor\nt *= delta(vectorizer_input(\"S=1/2\"),s[1])\nt *= delta(vectorizer_input(\"S=1/2\")', s[1]')\n\n# We combine the indices on t into a single \n# vecotorized index\nt *= vectorizer(\"S=1/2\")\n\n# We set the single index on t to be one of\n# our previously created vectorized indices\nt *= delta(vectorizer_output(\"s=1/2\"),sv[1])\n```\n\nsee also: `vectorizer_input`, `vectorizer`\n\n\n\n\n\n","category":"function"},{"location":"api/AutoMPOHermitianConjugate.html#Documentation-for-ITensorsOpenSystems.AutoMPOHermitianConjugate","page":"AutoMPOHermitianConjugate","title":"Documentation for ITensorsOpenSystems.AutoMPOHermitianConjugate","text":"","category":"section"},{"location":"api/AutoMPOHermitianConjugate.html","page":"AutoMPOHermitianConjugate","title":"AutoMPOHermitianConjugate","text":"ITensorsOpenSystems.AutoMPOHermitianConjugate.hermitianconj\nITensorsOpenSystems.AutoMPOHermitianConjugate.register_conjugate","category":"page"},{"location":"api/AutoMPOHermitianConjugate.html#ITensorsOpenSystems.AutoMPOHermitianConjugate.hermitianconj","page":"AutoMPOHermitianConjugate","title":"ITensorsOpenSystems.AutoMPOHermitianConjugate.hermitianconj","text":"hermitianconj(autompo)\nReturns the Hermitian conjugate of an autompo object. \n\n# example\n```julia-repl\njulia> H = OpSum()\nsum(\n\n)\n\njulia> H += 2, \"S+\", 1, \"Sz\",1\nsum(\n2.0 S+(1,) Sz(1,)\n)\n\njulia> H += [1 im; 2 3], 2\nsum(\n2.0 S+(1,) Sz(1,)\n1.0 Complex{Int64}[1 + 0im 0 + 1im; 2 + 0im 3 + 0im](2,)\n)\n\njulia> hermconj(H)\nsum(\n2.0 Sz(1,) S-(1,)\n1.0 Complex{Int64}[1 + 0im 2 + 0im; 0 - 1im 3 + 0im](2,)\n)\n```\n\nsee also: `register_conjugate`\n\n\n\n\n\n","category":"function"},{"location":"api/AutoMPOHermitianConjugate.html#ITensorsOpenSystems.AutoMPOHermitianConjugate.register_conjugate","page":"AutoMPOHermitianConjugate","title":"ITensorsOpenSystems.AutoMPOHermitianConjugate.register_conjugate","text":"register_conjugate(op::AbstractString;quiet=false)\nregister_conjugate(op::AbstractString,::Nothing;quiet=false)\nregister_conjugate(op1::AbstractString,op2::AbstractString; kwargs...)\n\nregisters an the name of an op allowing hermconj to take its conjugate. If one argument is\ngiven the op is assumed to be Hermitian. If two strings are given, both are registered as\nconjgates of each other. If the `symmetric` keyword is set to false only the the first\nargument is registered, with the second argment as its conjugate.\n\nAn arbitrary function can be applied particular parameters when taking the conjugate. This is passed\nvia the `parameter_transforms` keyword, which expects a dictionary mapping symbols (the parameters to be modified)\nto the funcitons to apply. Different funcitons can be applied to the arguments of each element of a conjugate\npair by passing the `parameter_transforms1` and `parameter_transforms2` keywords.\n\nA function can also be applied to the entire operator before it is returned allowing for complete control of the\nreturned conjugate. This is passed via the `op_transform` keyword. Seperate functions can be passed for each operator\nin a pair via the `op_transform1` and `op_transform2` keywords.\n\nIf nothing is given as an argument then it registered as not being able to take its hermitian conjugate.\n\nIf an op has previously been registered it will be overwriten but a warning will be raised. The warning\ncan be supressed by passing the `quiet` keyword.\n\n# Example\n```julia-repl\njulia> H = Op(\"Macbeth\",1)\n\"Macbeth\"(1,)\n\njulia> hermitianconj(H)\nERROR: NotInSymbolicSetError \"The hermitian conjugate of \"Macbeth\"(1,) is not in the set of symbolically defined ops\"\nStacktrace:\n  [1] top-level scope\n    @ REPL[5]:1\n\njulia> register_conjugate(\"Macbeth\",\"MacbethDag\")\n\njulia> hermitianconj(H)\n\"MacbethDag\"(1,)\n```\n\nsee also: `hermitianconj`\n\n\n\n\n\n","category":"function"},{"location":"getting_started/installation.html#installation","page":"installation","title":"Installing Julia and ITensorsOpenSystems.jl","text":"","category":"section"},{"location":"getting_started/installation.html#Installing-Julia","page":"installation","title":"Installing Julia","text":"","category":"section"},{"location":"getting_started/installation.html","page":"installation","title":"installation","text":"To start using ITensorsOpenSystems.jl you'll need Julia >= 1.9 installed. To do this visit https://julialang.org/downloads/ and follow the instructions for your operating system. You may also use your operating system's package manager.","category":"page"},{"location":"getting_started/installation.html#Installing-ITensorsOpenSystems.jl","page":"installation","title":"Installing ITensorsOpenSystems.jl","text":"","category":"section"},{"location":"getting_started/installation.html","page":"installation","title":"installation","text":"With Julia installed","category":"page"},{"location":"getting_started/installation.html","page":"installation","title":"installation","text":"Open a terminal and start the Julia REPL by typing julia\nType ] to enter the package manager\nEnter the command add https://github.com/ITensor-opensystems/ITensorsOpenSystems.jl.git\nOnce the installation is complete press backspace to take you to the julia> prompt\nEnter using ITensorsOpenSystems to ensure everything is installed","category":"page"},{"location":"getting_started/installation.html","page":"installation","title":"installation","text":"You're now ready to start one of our tutorials.","category":"page"},{"location":"api/Superfermions.html#Documentation-for-ITensorsOpenSystems.Superfermions","page":"Superfermions","title":"Documentation for ITensorsOpenSystems.Superfermions","text":"","category":"section"},{"location":"api/Superfermions.html","page":"Superfermions","title":"Superfermions","text":"ITensorsOpenSystems.Superfermions.anticommutatorapply\nITensorsOpenSystems.Superfermions.clear_cached_vacuums\nITensorsOpenSystems.Superfermions.commutatorapply\nITensorsOpenSystems.Superfermions.delete_cached_vacuuum\nITensorsOpenSystems.Superfermions.leftapply\nITensorsOpenSystems.Superfermions.leftrightapply\nITensorsOpenSystems.Superfermions.leftvacuum\nITensorsOpenSystems.Superfermions.lindbladdissipator\nITensorsOpenSystems.Superfermions.rightapply\nITensorsOpenSystems.Superfermions.superfermioncorrelation\nITensorsOpenSystems.Superfermions.superfermionexpect\nITensorsOpenSystems.Superfermions.superfermioninds\nITensorsOpenSystems.Superfermions.superfermiontrace","category":"page"},{"location":"api/Superfermions.html#ITensorsOpenSystems.Superfermions.anticommutatorapply","page":"Superfermions","title":"ITensorsOpenSystems.Superfermions.anticommutatorapply","text":"anticommutatorapply(o) -> Sum\n\nCompute the anticommutator action of operator o in the superfermion representation.\n\nArguments\n\no: The operator for which the anticommutator action is to be computed.\n\nReturns\n\nA Sum object representing the anticommutator operator.\n\nSee Also\n\nleftapply\nrightapply\ncommutatorapply\n\n\n\n\n\n","category":"function"},{"location":"api/Superfermions.html#ITensorsOpenSystems.Superfermions.clear_cached_vacuums","page":"Superfermions","title":"ITensorsOpenSystems.Superfermions.clear_cached_vacuums","text":"clear_cached_vacuums()\n\nDeletes all memorized left vacuum states created by leftvacuum.\n\nsee also leftvacuum, delete_cached_vacuuum\n\n\n\n\n\n","category":"function"},{"location":"api/Superfermions.html#ITensorsOpenSystems.Superfermions.commutatorapply","page":"Superfermions","title":"ITensorsOpenSystems.Superfermions.commutatorapply","text":"commutatorapply(o) -> Sum\n\nCompute the commutator action of operator o in the superfermion representation.\n\nArguments\n\no: operator\n\nReturns\n\nA Sum object representing the commutator operator.\n\nSee Also\n\nleftapply\nrightapply\nanticommutatorapply\n\n\n\n\n\n","category":"function"},{"location":"api/Superfermions.html#ITensorsOpenSystems.Superfermions.delete_cached_vacuuum","page":"Superfermions","title":"ITensorsOpenSystems.Superfermions.delete_cached_vacuuum","text":"delete_cached_vacuuum(indices::Vector{<:Index})::MPS\n\nDeletes the left vacuum state memorized by leftvacuum for the given set of indices. The deleted state is returned.\n\nsee also leftvacuum, clear_cached_vacuums\n\n\n\n\n\n","category":"function"},{"location":"api/Superfermions.html#ITensorsOpenSystems.Superfermions.leftapply","page":"Superfermions","title":"ITensorsOpenSystems.Superfermions.leftapply","text":" leftapply(o::T) where {T<:Any}\n\nCreates an autoMPO representation of the superfermion operator equivelant to left multiplying the density operator by o. o must be given as an autoMPO  object.\n\n#Examples\n\n# Build the operator standard Hilbert space operaotr C†_1 C_2 + N_1\no = OpSum()\no += \"Cdag\", 1 \"C\" 2\no += \"N\", 1\n\n# Build the superfermion operator ρ →(C†_1 C_2 + N_1)ρ as an autoMPO object\nl = leftapply(o)\n\n# Build an MPO representation of l\nindices = superfermioninds(4)\nl_mpo = MPO(l,s)\n\nsee also rightapply, leftrightapply, commutatorapply, anticommutatorapply\n\n\n\n\n\n","category":"function"},{"location":"api/Superfermions.html#ITensorsOpenSystems.Superfermions.leftrightapply","page":"Superfermions","title":"ITensorsOpenSystems.Superfermions.leftrightapply","text":"leftrightapply(ol,or)\nleftrightapply(ol::Op, or::Op)::Scaled{_FieldType,Prod{Op}}\nleftrightapply(ol::Prod{T}, or::Prod{T})::Scaled{_FieldType,Prod{T}} where {T<:Op}\nleftrightapply(\nol::Scaled{<:Number,Prod{T}},\nor::Scaled{<:Number,Prod{T}},\n\n)::Scaled{<:Number,Prod{T}} where {T<:Op}\n\nCreates an autoMPO representation of the superfermion operator equivelant to simultaniously left multiplying the density operator by ol and right multiplying by or. ol and or must be given as autoMPO objects.\n\n#Examples\n\n# Build the standard Hilbert space operator 2.0 C_1 C†_2\ns_left = OpSum()\ns_left += 2.0 \"C\", 1, \"Cdag\" 2\n\n# Build the standard Hilbert space operator N_1 + 2.0 N_2\ns_right = OpSum()\ns_right += \"N\", 1\ns_right += 2.0, \"N\", 2\n\n# Build the superfermion operator ρ → (2.0 C_1 C†_2) ρ (N_1 + 2.0 N_2)\nsuperfemion_op = leftrightapply(s_left,s_right)\n\n# Construct superfermion MPO\nindices = superfermioninds(2)\nO = MPO(superfemion_op,indices)\n\nsee also leftapply, rightapply, commutatorapply, anticommutatorapply\n\n\n\n\n\n","category":"function"},{"location":"api/Superfermions.html#ITensorsOpenSystems.Superfermions.leftvacuum","page":"Superfermions","title":"ITensorsOpenSystems.Superfermions.leftvacuum","text":"leftvacuum([NoCache,] indices::Vector{<:Index})::MPS\n\nReturns the left vacuum state for a set of superfermion indices. Memorization is used to avoid repeatedly recomputing the state for a given set of indices. If the NoCache option is given, the state will always be directly computed, without querrying or overwriting the cached state.\n\n#Examples\n\nsuperfermion_indices = superfermioninds(5) # Create a set of indices describing a system \nleftvac1 = leftvacuum(superfermion_indices) # Create the left vacuum statte for the system, memorizing the result\nleftvac2 = leftvacuum(superfermion_indices) # Uses the cached result. No additional calculation is carried out\nleftvac3 = leftvacuum(NoCache, superfermion_indices) # Ignores the cahce and recomputes the left vacuum state \n\nSee also clear_cached_vacuums, delete_cached_vacuuum`\n\n\n\n\n\n","category":"function"},{"location":"api/Superfermions.html#ITensorsOpenSystems.Superfermions.lindbladdissipator","page":"Superfermions","title":"ITensorsOpenSystems.Superfermions.lindbladdissipator","text":"lindbladdissipator(jump_op::AbstractString,i::Integer)::Sum\n\nCreates an autoMPO superfermion representation of a Lindblad dissipator with a jump operator jump_op on (physical) site i. #Examples\n\ndis = OpSum()\n\n# Add dissipator, removing fermions from the system, on site 1\n# 0.1 * (C ρ C† - 1/2 { C†C,ρ } )\nextraction_rate = 0.1\ndis += extraction_rate * lindbladdissipator(\"C\",1)\n\n# Add dissipator, injecting fermions into the system, on site 5\n# 0.3 * ( C† ρ C - 1/2 { CC†,ρ })\ninjection_rate = 0.3\ndis += injection_rate * lindbladdissipator(\"Cdag\",5)\n\n# Build operator as MPO\nindices = superfermioninds(5)\ndissipation_MPO = MPO(dis,indices)\n\nsee also leftrightapply, commutatorapply, anticommutatorapply, leftapply, rightapply\n\n\n\n\n\n","category":"function"},{"location":"api/Superfermions.html#ITensorsOpenSystems.Superfermions.rightapply","page":"Superfermions","title":"ITensorsOpenSystems.Superfermions.rightapply","text":" rightapply(o::T) where {T<:Any}\n\nCreates an autoMPO representation of the superfermion operator equivelant to right multiplying the density operator by o. o must be given as an autoMPO  object.\n\n#Examples\n\n# Build the operator standard Hilbert space operaotr C†_1 C_2 + N_1\no = OpSum()\no += \"Cdag\", 1 \"C\" 2\no += \"N\", 1\n\n# Build the superfermion operator ρ →ρ(C†_1 C_2 + N_1) as an autoMPO object\nr = leftapply(o)\n\n# Build an MPO representation of r\nindices = superfermioninds(4)\nr_mpo = MPO(r,s)\n\nsee also leftapply, leftrightapply, commutatorapply, anticommutatorapply\n\n\n\n\n\n","category":"function"},{"location":"api/Superfermions.html#ITensorsOpenSystems.Superfermions.superfermioncorrelation","page":"Superfermions","title":"ITensorsOpenSystems.Superfermions.superfermioncorrelation","text":"superfermioncorrelation(state::MPS,op1::Union{String,Matrix},op2::Union{String,Matrix}; normalize=true)::Matrix{ITensors.promote_itensor_eltype(state)}\n\nCalculates the correlation matrix for a pair of operators op1 and op2 for a given state, that is calculates the expectation of the operator op1i * op2j for i and j iterating through each physical site of the system.\n\n#Example\n\nindices = superfermioninds(5)\nrho = leftvacuum(indices)\ng = superfermioncorrelation(rho,\"Cdag\",\"C\")\n\nsee also superfermionexpect\n\n\n\n\n\n","category":"function"},{"location":"api/Superfermions.html#ITensorsOpenSystems.Superfermions.superfermionexpect","page":"Superfermions","title":"ITensorsOpenSystems.Superfermions.superfermionexpect","text":"superfermionexpect(state::MPS,oper::AbstractString;[sites,] normalize::Bool=true)::Vector{ITensors.promote_itensor_eltype(rho)}\n\nCalculates the expectation value of the operator oper on each physical site of the superfermion state state. If the sites keyword is given, the expectation is only evaluated for those physical sites in the given range. If normalize is true the result will be normalized by the trace of the input state.\n\n#Example\n\nindices = superfermioninds(5)\nρ = leftvacuum(indices)\n\n# Compute the occupation of all sites\noccupations = superfermionexpect(ρ,\"N\")\n\n# Compute the occupation of only sites 1 and 3\noccupations_1_and_3 = superfermionexpect(ρ,\"N\";sites=[1,3]) \n\nsee also superfermioncorrelation\n\n\n\n\n\n","category":"function"},{"location":"api/Superfermions.html#ITensorsOpenSystems.Superfermions.superfermioninds","page":"Superfermions","title":"ITensorsOpenSystems.Superfermions.superfermioninds","text":"superfermioninds(n::Integer;conserve_qns=false)::Vector{<:Index}\n\nConstructs a set of superfermion indices for n physical sites. That is  the result will contain 2n indices, with n system indices and n ancilla indices. If conserve_qns=true then the indices will keep track of particle number flux.\n\n\n\n\n\n","category":"function"},{"location":"api/Superfermions.html#ITensorsOpenSystems.Superfermions.superfermiontrace","page":"Superfermions","title":"ITensorsOpenSystems.Superfermions.superfermiontrace","text":"superfermiontrace(rho::MPS)::ITensors.promote_itensor_eltype(rho)\n\nCalculates the trace of the density matrix given as a superfermion state rho\n\n\n\n\n\n","category":"function"},{"location":"tutorials/tutorial1.html#tutorial1","page":"tutorial1","title":"Tutorial 1 - End to end","text":"","category":"section"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"using ITensors\nusing ITensorsOpenSystems\nusing Plots\nusing LinearAlgebra","category":"page"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"The density matrix rho of a dissipative spin system evolves as","category":"page"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"fracddtrho(t) = mathcalLrho(t)","category":"page"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"defined by the Liouvillian superoperator","category":"page"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"mathcalLrho(t) = -iHrho(t) + sum_q=1^JmathcalD_A_jrho","category":"page"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"where H is the system Hamiltonian and ","category":"page"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"mathcalD_Arho = Arho A^dagger - frac12A^dagger A rho - frac12rho A^dagger A","category":"page"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"is the Lindblad dissipator for a jump operator A. In this tutorial we will consider a system comprising a chain of N spin-1/2's governed by the XXZ Hamiltonian with a transverse field","category":"page"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"H = sum_i=1^N-1left(sigma^x_isigma^x_i+1 + sigma^y_isigma^y_i+1 + Deltasigma^z_isigma^z_i+1right) + hsum_i=1^Nsigma^x_i","category":"page"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"and apply J=3 jump operators","category":"page"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"beginaligned\nA_1 = sqrtgamma_rm insigma^+_1\nA_2 = sqrtgamma_rm outsigma^-_N\nA_3 = sqrtgamma_rm dpsum_i=1^Nsigma^z_i\nendaligned","category":"page"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"describing the injection of spin uparrow excitations at the first spin, their ejection at the last spin, and dephasing of the collective z magnetization. We will consider small system sizes N to allow comparison to exact diagonalization.","category":"page"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"begin\n\tN    = 3    \t\t\t\t\t# Number of spins\n\tΔ    = 1.5  \t\t\t\t\t# Anisotropy of the spin-spin coupling\n\th    = 0.6  \t\t\t\t\t# Transverse field strength\n\tγin  = 0.4  \t\t\t\t\t# Spin-injection noise rate\n\tγout = 0.2  \t\t\t\t\t# Spin-ejection noise rate \n\tγdp  = 0.8  \t\t\t\t\t# Collective dephasing noise rate\nend;\n\nsystem = siteinds(\"S=1/2\",N); \t\t# Define system spin-1/2 Hilbert space\n\nfatsys = fatsiteinds(system); \t\t# Define the vectorized Hilbert space","category":"page"},{"location":"tutorials/tutorial1.html#Define-Hamiltonian-and-jump-operators","page":"tutorial1","title":"Define Hamiltonian and jump operators","text":"","category":"section"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"We first construct the system Hamiltonian OpSum","category":"page"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"begin\n\tH = OpSum()\n\n\t# Open boundary chain:\n\tfor i = 1:(N-1)\n    \tH += h, \"X\", i \t\t\t\t# Transverse field\n    \n    \tH += 1, \"X\", i, \"X\", i+1 \t# XX term\n    \tH += 1, \"Y\", i, \"Y\", i+1 \t# YY term\n    \tH += Δ, \"Z\", i, \"Z\", i+1 \t# ZZ term\n\tend\n\tH += h, \"X\", N  \t\t\t\t# Transverse field on last spin\nend;","category":"page"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"Thenn define Lindblad jump operators","category":"page"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"begin\n\tA = fill(OpSum(), 3)         \t# An array of OpSum's for jump operators\n\n\tA[1] += sqrt(γin), \"Sp\", 1    \t# Spin injection\n\tA[2] += sqrt(γout), \"Sm\", N   \t# Spin ejection\n\n\tfor i = 1:N\n    \tA[3] += sqrt(γdp), \"Z\", i \t# Collective dephasing\n\tend\nend","category":"page"},{"location":"tutorials/tutorial1.html#Construct-MPOs","page":"tutorial1","title":"Construct MPOs","text":"","category":"section"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"Hmpo = MPO(H,system);           \t# Build the system Hamiltonian MPO\n\nLH = im * commutator(H,fatsys); \t# Build the commutator MPO for the fat-system\n\nLD = dissipator(A,fatsys);      \t# Build the dissipator MPO for the fat-system\n\nL = LH + LD;                    \t# Full Liouvillian MPO for the fat-system\n\nLdagL = apply(dagprimes(L),L);   \t# Construct Liouvillian \"Hamiltonian\"","category":"page"},{"location":"tutorials/tutorial1.html#Compute-stationary-state","page":"tutorial1","title":"Compute stationary state","text":"","category":"section"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"Perform standard DMRG sweeps to find the \"ground state\" of the Liovillian Hamiltonian.","category":"page"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"begin\n\tsweeps = Sweeps(10)\t\t\t\t# Initialize sweeps with number \n    maxdim!(sweeps,50,100,200,400,800,800,1000,1000,2000,2000) # Bond dimension      \n    cutoff!(sweeps,1E-10)  \t\t\t# Desired truncation error\n\tρ0 = randomMPS(fatsys, \"↑\"; linkdims=10) \t# Create a random initial state\nend\n\nval, ρ = dmrg(LdagL,ρ0,sweeps);\t\t# Find the steady-state ","category":"page"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"Now compute observables from the steady state:","category":"page"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"magz = expect(ρ,\"Sz\"); \t\t\t\t# Compute z-magnetization profile\n\nzz = correlation_matrix(ρ,\"Sp\",\"Sm\"); \t# Compute S+S- correlation matrix \n","category":"page"},{"location":"tutorials/tutorial1.html#Exact-diagonalization","page":"tutorial1","title":"Exact diagonalization","text":"","category":"section"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"Compute the exact result for comparison. Start by constructing the full 2^2N times 2^2N matrix for the Liouvillian Hamiltonian:","category":"page"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"if N > 10\n\tthrow(\"System size too large for exact diagonalization\") \t# Don't continue\nend\n\nbegin\n\tLH_ed = im * full_commutator(H,fatsys); \n\tLD_ed = full_dissipator(A,fatsys); \n\tL_ed = LH_ed + LD_ed;\nend","category":"page"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"Now fully diagonalize to find the steady-state","category":"page"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"begin\n\tF = eigen(L_ed)\t\t\t\t# Diagonalize matrix\n\tE = F.values \t\t\t\t# Extract eigenvalues\n\tV = F.vectors \t\t\t\t# Extract eigenvectors\n\tind = findmin(E) \t\t\t# Locate the smallest eigenvalue (should be zero)\n\tρ_ed = V[:,ind] \t\t\t# Extract the corresponding eigenvector\n\tρ_ed = reshape(ρ_ed, (2^N,2^N)); \t# Reshape vector into a matrix\nend","category":"page"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"Compute observables from the steady-state","category":"page"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"magz_ed = expect(ρ_ed,\"Sz\"); \t\t\t\t# Compute z-magnetization profile\n\nzz_ed = correlation_matrix(ρ_ed,\"Sp\",\"Sm\"); # Compute S+S- correlation matrix","category":"page"},{"location":"tutorials/tutorial1.html#Compare-results","page":"tutorial1","title":"Compare results","text":"","category":"section"},{"location":"tutorials/tutorial1.html","page":"tutorial1","title":"tutorial1","text":"begin\n\tplot(1:N, magz_ed, label=\"exact\")  \n\tscatter!(1:N, magz, label=\"MPO\") \n\theatmap(1:N, 1:N, real(zz), c = :heat)\n\tfontsize = 10\n\tnrow, ncol = size(zz)\n\tann = [(i,j, text(round(real(zz[i,j]), digits=3), fontsize, :white, :center))\n            for i in 1:nrow for j in 1:ncol]\n\t\t\tannotate!(ann, linecolor=:white)\n\theatmap(1:N, 1:N, real(zz_ed), c = :heat)\n\tfontsize = 10\n\tnrow, ncol = size(zz)\n\tann = [(i,j, text(round(real(zz_ed[i,j]), digits=3), fontsize, :white, :center))\n            for i in 1:nrow for j in 1:ncol]\n\t\t\tannotate!(ann, linecolor=:white)\nend","category":"page"},{"location":"api/private/_InternalUtils.html#Documentation-for-ITensorsOpenSystems._InternalUtils","page":"_InternalUtils","title":"Documentation for ITensorsOpenSystems._InternalUtils","text":"","category":"section"},{"location":"api/private/_InternalUtils.html","page":"_InternalUtils","title":"_InternalUtils","text":"ITensorsOpenSystems._InternalUtils.autoMPO_multiply\nITensorsOpenSystems._InternalUtils.partition_kwargs\nITensorsOpenSystems._InternalUtils.partition_nosigil\nITensorsOpenSystems._InternalUtils.partitionsets","category":"page"},{"location":"api/private/_InternalUtils.html#ITensorsOpenSystems._InternalUtils.autoMPO_multiply","page":"_InternalUtils","title":"ITensorsOpenSystems._InternalUtils.autoMPO_multiply","text":"autoMPOmultiply(a::Scaled,b::Prod)::Scaled autoMPOmultiply(a::Sum,b::Sum) autoMPOmultiply(a::Sum,b) autoMPOmultiply(a,b::Sum) autoMPO_multiply(a, b)\n\nMultiplies a pair of autoMPO objects in such a way that the result is an \"expected form\"  That is it will always produce a sum of products, rather than a product of sums  and it will correctly multiply a Scaled by a Prod\n\n\n\n\n\n","category":"function"},{"location":"api/private/_InternalUtils.html#ITensorsOpenSystems._InternalUtils.partition_kwargs","page":"_InternalUtils","title":"ITensorsOpenSystems._InternalUtils.partition_kwargs","text":"function partition_kwargs(kwargs,sigils::String...)::Dict{String,<:Dict}\n\nSeparates a named tuple into subsets based on suffixes of the keywords\nreturns a dictionary taking the suffixes as the keys and with a dictionary\nof keywords (with the suffix removed) and associated values\n\n\n\n\n\n","category":"function"},{"location":"api/private/_InternalUtils.html#ITensorsOpenSystems._InternalUtils.partition_nosigil","page":"_InternalUtils","title":"ITensorsOpenSystems._InternalUtils.partition_nosigil","text":"const partition_nosigil = \"No Sigil\"     unsure exactly what this \n\n\n\n\n\n","category":"constant"},{"location":"api/private/_InternalUtils.html#ITensorsOpenSystems._InternalUtils.partitionsets","page":"_InternalUtils","title":"ITensorsOpenSystems._InternalUtils.partitionsets","text":"partitionsets(s1::Set, s2::Set)::Tuple{Set,Set,Set}\n\nGiven two sets, setarates the elements into those that are only in the first,  those that are in both and those that are only in the second \n\n\n\n\n\n","category":"function"},{"location":"api/Utils.html#Documentation-for-ITensorsOpenSystems.Utils","page":"Utils","title":"Documentation for ITensorsOpenSystems.Utils","text":"","category":"section"},{"location":"api/Utils.html","page":"Utils","title":"Utils","text":"ITensorsOpenSystems.Utils.MPOtomatrix\nITensorsOpenSystems.Utils.MPStovector\nITensorsOpenSystems.Utils.dagprimes\nITensorsOpenSystems.Utils.dagprimes!\nITensorsOpenSystems.Utils.reduced_density_matrix\nITensorsOpenSystems.Utils.reduced_density_matrix!\nITensorsOpenSystems.Utils.stateequality\nITensorsOpenSystems.Utils.thermofield_mapping","category":"page"},{"location":"api/Utils.html#ITensorsOpenSystems.Utils.MPOtomatrix","page":"Utils","title":"ITensorsOpenSystems.Utils.MPOtomatrix","text":"MPOtomatrix(s::MPO)::Matrix{<:Number}\n\nConverts and MPO into a standard julia matrix\n\nwarning: the matrix dimension can get large quickly. Only use on operators with a small number of sites\n\n\n\n\n\n","category":"function"},{"location":"api/Utils.html#ITensorsOpenSystems.Utils.MPStovector","page":"Utils","title":"ITensorsOpenSystems.Utils.MPStovector","text":"MPStovector(s::MPS)::Vector{<:Number}\n\nConverts and MPS into a standard julia vector\n\nwarning: the vector dimension can get large quickly. Only use on states with a small number of sites\n\n\n\n\n\n","category":"function"},{"location":"api/Utils.html#ITensorsOpenSystems.Utils.dagprimes","page":"Utils","title":"ITensorsOpenSystems.Utils.dagprimes","text":"dagprimes(o;kwargs...)\n\nTakes the Hermitian conjugate of an MPO or ITensor, using the convention that input indices have prime level 0 and the corresponding output indices are the same index with prime level 1. Accepts the same keyword arguments  as dag, prime and similar functions\n\n\n\n\n\n","category":"function"},{"location":"api/Utils.html#ITensorsOpenSystems.Utils.dagprimes!","page":"Utils","title":"ITensorsOpenSystems.Utils.dagprimes!","text":"dagprimes!(o;kwargs...)\n\nTakes the Hermitian conjugate of an MPO in place, using the convention that input indices have prime level 0 and the corresponding output indices are the same index with prime level 1. Accepts the same keyword arguments  as dag, prime and similar functions\n\nsee also: dagprimes\n\n\n\n\n\n","category":"function"},{"location":"api/Utils.html#ITensorsOpenSystems.Utils.reduced_density_matrix","page":"Utils","title":"ITensorsOpenSystems.Utils.reduced_density_matrix","text":"reduced_density_matrix(ψ::MPS,remaining_indices;kwargs...)::MPO\n\nGiven a state as an MPO or MPS calculates the reduced density matrix obtained by tracing  all the indices except those in remaining_indices, giving the result as an MPO. If the  original state is given as an MPO, an in-place version exists.\n\nA truncation of the MPO can be incorperated. Parameters for this e.g. cutoff, maxdim, etc. can be passed as extra keyword arguments.\n\nExample\n\ns = siteinds(\"S=1/2\",4)\n\n# density matrix for the product state with all spins pointing up\nρ = MPO(s, \"ProjUp\")\n\n# traces out sites 3 and 4 to give the reduced density matrix on sites 1 and 2\nρ_12 = reduced_density_matrix(ρ,s[1:2])\n\n\n\n\n\n","category":"function"},{"location":"api/Utils.html#ITensorsOpenSystems.Utils.reduced_density_matrix!","page":"Utils","title":"ITensorsOpenSystems.Utils.reduced_density_matrix!","text":"reduced_density_matrix!(ρ::MPO,remaining_indices;kwargs...)::MPO\n\nGiven a state as an MPO or MPS calculates the reduced density matrix obtained by tracing  all the indices except those in remaining_indices, giving the result as an MPO. If the  original state is given as an MPO, an in-place version exists.\n\nA truncation of the MPO can be incorperated. Parameters for this e.g. cutoff, maxdim, etc. can be passed as extra keyword arguments.\n\nExample\n\ns = siteinds(\"S=1/2\",4)\n\n# density matrix for the product state with all spins pointing up\nρ = MPO(s, \"ProjUp\")\n\n# traces out sites 3 and 4 to give the reduced density matrix on sites 1 and 2\nρ_12 = reduced_density_matrix(ρ,s[1:2])\n\n\n\n\n\n","category":"function"},{"location":"api/Utils.html#ITensorsOpenSystems.Utils.stateequality","page":"Utils","title":"ITensorsOpenSystems.Utils.stateequality","text":" stateequality(s1::MPS,s2::MPS;kwargs...)::Bool\n\nReturns true if the MPSs s1 and s2 correspond to the same tensor, to within numerical precision, and false otherwise. This is useful due to the level of gauge freedom in representing an MPS\n\nIt can optionally be passed an atol and rtol to set the absolute and relative numerical tolerance respectively.  \n\n\n\n\n\n","category":"function"},{"location":"api/Utils.html#ITensorsOpenSystems.Utils.thermofield_mapping","page":"Utils","title":"ITensorsOpenSystems.Utils.thermofield_mapping","text":"thermofield_mapping(spectral_density::Function,temperature::Real,chemical_potential::Real=0.0;bosonic::Bool=true)::Tuple{Function,Function}\nthermofield_mapping(energies::Vector{<:Real},couplings::Vector{<:Real},temperature::Real,chemical_potential::Real=0.0;bosonic::Bool=true)::Tuple{Vector{<:Real},Vector{<:Real}}\n\nComputes a thermofield mapping on a bath. Given a spectral density and temperature, and optional chemical potential it will return a pair of functions giving the spectral density on the negative and positive energy states (given in that order)\n\nGiven a list of the energies of bath states and the couplings to those states it will return  a pair of lists of the couplings to the negative and positive energy thermofield states (again in that order)\n\nIf the bosonic keyword is set to true (the default) it will perform the mapping for bosonic bath states. If it is set to false it will perform the mapping for fermionic bath states. \n\n\n\n\n\n","category":"function"},{"location":"tutorials/fermions.html#Fermions","page":"fermions","title":"Fermions","text":"","category":"section"},{"location":"tutorials/fermions.html","page":"fermions","title":"fermions","text":"...","category":"page"},{"location":"index.html#Documentation","page":"index","title":"Documentation","text":"","category":"section"},{"location":"index.html","page":"index","title":"index","text":"ITensorsOpenSystems","category":"page"},{"location":"api/ChainMappings.html#Documentation-for-ITensorsOpenSystems.ChainMappings","page":"ChainMappings","title":"Documentation for ITensorsOpenSystems.ChainMappings","text":"","category":"section"},{"location":"api/ChainMappings.html","page":"ChainMappings","title":"ChainMappings","text":"","category":"page"},{"location":"api/MatrixConstruction.html#Documentation-for-ITensorsOpenSystems.MatrixConstruction","page":"MatrixConstruction","title":"Documentation for ITensorsOpenSystems.MatrixConstruction","text":"","category":"section"},{"location":"api/MatrixConstruction.html","page":"MatrixConstruction","title":"MatrixConstruction","text":"ITensorsOpenSystems.MatrixConstruction.buildmatrix","category":"page"},{"location":"api/MatrixConstruction.html#ITensorsOpenSystems.MatrixConstruction.buildmatrix","page":"MatrixConstruction","title":"ITensorsOpenSystems.MatrixConstruction.buildmatrix","text":"buildmatrix(\n    matrixType::Type{M},\n    operator::OpSum,\n    indices,\n)::M where {M<:Union{<:AbstractMatrix,<:AbstractSparseMatrix}}\n\nbuildmatrix(\nmatrixType::Type{M},\noperator::OpSum,\nindices,\n\n)::M where {M<:Union{Hermitian,SymTridiagonal}}\n\nConstructs a matrix representation of an operator defined as an OpSum.\n\nThis function builds a dense or sparse matrix (of type M) representation for a quantum operator given by operator using a specified set of indices. The indices determine the dimensions and ordering of the matrix representation. Internally, each term of the operator is converted to a tensor (using _tensor_from_autoMPO), and the tensor indices are mapped to linear matrix indices based on the ordering provided by indices.\n\nArguments\n\nmatrixType::Type{M}: The matrix type to construct, where M must be a subtype of AbstractMatrix or AbstractSparseMatrix.\noperator::OpSum: The operator (expressed as a sum of terms) for which the matrix representation is built.\nindices: A collection of indices defining the matrix's basis. Each index must have a prime level (plev) of 0, and duplicate indices are not allowed.\n\nReturns\n\nA matrix of type M with dimensions equal to the product of the dimensions of the provided indices. This matrix represents the operator in the basis specified by indices.\n\n\n\n\n\n","category":"function"}]
}
